{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to prismatools","text":"<p>prismatools is an open-source Python package for reading, analyzing, and visualizing hyperspectral imagery from the PRISMA mission.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://gthlor.github.io/prismatools</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/gthlor/prismatools/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>prismatools could always use more documentation, whether as part of the official prismatools docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/gthlor/prismatools/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up prismatools for local development.</p> <ol> <li> <p>Fork the prismatools repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/prismatools.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv prismatools\n$ cd prismatools/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 prismatools tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/gthlor/prismatools/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"gui/","title":"gui module","text":"<p>This module contains the user interface for the prismatools package.</p>"},{"location":"gui/#prismatools.gui.spectralWidget","title":"<code> spectralWidget            (HBox)         </code>","text":"<p>A widget for spectral data visualization on a map.</p> <p>Attributes:</p> Name Type Description <code>_host_map</code> <code>Map</code> <p>The map to host the widget.</p> <code>on_close</code> <code>function</code> <p>Function to be called when the widget is closed.</p> <code>_output_widget</code> <code>widgets.Output</code> <p>The output widget to display results.</p> <code>_output_control</code> <code>ipyleaflet.WidgetControl</code> <p>The control for the output widget.</p> <code>_on_map_interaction</code> <code>function</code> <p>Function to handle map interactions.</p> <code>_spectral_widget</code> <code>SpectralWidget</code> <p>The spectral widget itself.</p> <code>_spectral_control</code> <code>ipyleaflet.WidgetControl</code> <p>The control for the spectral widget.</p> Source code in <code>prismatools/gui.py</code> <pre><code>class spectralWidget(widgets.HBox):\n    \"\"\"\n    A widget for spectral data visualization on a map.\n\n    Attributes:\n        _host_map (Map): The map to host the widget.\n        on_close (function): Function to be called when the widget is closed.\n        _output_widget (widgets.Output): The output widget to display results.\n        _output_control (ipyleaflet.WidgetControl): The control for the output widget.\n        _on_map_interaction (function): Function to handle map interactions.\n        _spectral_widget (SpectralWidget): The spectral widget itself.\n        _spectral_control (ipyleaflet.WidgetControl): The control for the spectral widget.\n    \"\"\"\n\n    def __init__(\n        self, host_map, stack=True, position=\"topright\", xlim=None, ylim=None, **kwargs\n    ):\n        \"\"\"\n        Initializes a new instance of the SpectralWidget class.\n\n        Args:\n            host_map (Map): The map to host the widget.\n            stack (bool, optional): Whether to stack the plots. Defaults to True.\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n            xlim (tuple, optional): The x-axis limits. Defaults to None.\n            ylim (tuple, optional): The y-axis limits. Defaults to None.\n        \"\"\"\n        self._host_map = host_map\n        self.on_close = None\n        self._stack = stack\n        self._show_plot = False\n\n        fig_margin = {\"top\": 20, \"bottom\": 35, \"left\": 50, \"right\": 20}\n        fig = plt.figure(\n            # title=None,\n            fig_margin=fig_margin,\n            layout={\"width\": \"500px\", \"height\": \"300px\"},\n        )\n\n        self._fig = fig\n        self._host_map._fig = fig\n\n        layer_names = list(host_map.cog_layer_dict.keys())\n        layers_widget = widgets.Dropdown(options=layer_names)\n        layers_widget.layout.width = \"18ex\"\n\n        close_btn = widgets.Button(\n            icon=\"times\",\n            tooltip=\"Close the widget\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        reset_btn = widgets.Button(\n            icon=\"trash\",\n            tooltip=\"Remove all markers\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        stack_btn = widgets.ToggleButton(\n            value=stack,\n            icon=\"area-chart\",\n            tooltip=\"Stack spectral signatures\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        def reset_btn_click(_):\n            if hasattr(self._host_map, \"_plot_marker_cluster\"):\n                self._host_map._plot_marker_cluster.markers = []\n                self._host_map._plot_markers = []\n\n            if hasattr(self._host_map, \"_spectral_data\"):\n                self._host_map._spectral_data = {}\n\n            self._output_widget.clear_output()\n            self._show_plot = False\n            plt.clear()\n\n        reset_btn.on_click(reset_btn_click)\n\n        save_btn = widgets.Button(\n            icon=\"floppy-o\",\n            tooltip=\"Save the data to a CSV\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        def chooser_callback(chooser):\n            if chooser.selected:\n                file_path = chooser.selected\n                self._host_map.spectral_to_csv(file_path)\n                if (\n                    hasattr(self._host_map, \"_file_chooser_control\")\n                    and self._host_map._file_chooser_control in self._host_map.controls\n                ):\n                    self._host_map.remove_control(self._host_map._file_chooser_control)\n                    self._host_map._file_chooser.close()\n\n        def save_btn_click(_):\n            if not hasattr(self._host_map, \"_spectral_data\"):\n                return\n\n            self._output_widget.clear_output()\n            file_chooser = FileChooser(\n                os.getcwd(), layout=widgets.Layout(width=\"454px\")\n            )\n            file_chooser.filter_pattern = \"*.csv\"\n            file_chooser.use_dir_icons = True\n            file_chooser.title = \"Save spectral data to a CSV file\"\n            file_chooser.default_filename = \"spectral_data.csv\"\n            file_chooser.show_hidden = False\n            file_chooser.register_callback(chooser_callback)\n            file_chooser_control = ipyleaflet.WidgetControl(\n                widget=file_chooser, position=\"topright\"\n            )\n            self._host_map.add(file_chooser_control)\n            setattr(self._host_map, \"_file_chooser\", file_chooser)\n            setattr(self._host_map, \"_file_chooser_control\", file_chooser_control)\n\n        save_btn.on_click(save_btn_click)\n\n        def close_widget(_):\n            self.cleanup()\n\n        close_btn.on_click(close_widget)\n\n        super().__init__([layers_widget, stack_btn, reset_btn, save_btn, close_btn])\n\n        output = widgets.Output()\n        output_control = ipyleaflet.WidgetControl(widget=output, position=\"bottomright\")\n        self._output_widget = output\n        self._output_control = output_control\n        self._host_map.add(output_control)\n\n        if not hasattr(self._host_map, \"_spectral_data\"):\n            self._host_map._spectral_data = {}\n\n        def handle_interaction(**kwargs):\n\n            latlon = kwargs.get(\"coordinates\")\n            lat = latlon[0]\n            lon = latlon[1]\n            if kwargs.get(\"type\") == \"click\" and self._host_map._layer_editor is None:\n                layer_name = layers_widget.value\n\n                if not hasattr(self._host_map, \"_plot_markers\"):\n                    self._host_map._plot_markers = []\n                markers = self._host_map._plot_markers\n                marker_cluster = self._host_map._plot_marker_cluster\n                markers.append(ipyleaflet.Marker(location=latlon, draggable=False))\n                marker_cluster.markers = markers\n                self._host_map._plot_marker_cluster = marker_cluster\n\n                xlabel = \"Wavelength (nm)\"\n                ylabel = \"Reflectance\"\n\n                ds = self._host_map.cog_layer_dict[layer_name][\"xds\"]\n\n                if self._host_map.cog_layer_dict[layer_name][\"hyper\"] == \"PRISMA\":\n                    da = extract_prisma(ds, lat, lon)\n\n                self._host_map._spectral_data[f\"({lat:.4f} {lon:.4f})\"] = da.values\n\n                if self._host_map.cog_layer_dict[layer_name][\"hyper\"] != \"XARRAY\":\n                    da[da &lt; 0] = np.nan\n                    x_axis_options = {\"label_offset\": \"30px\"}\n                else:\n                    x_axis_options = {\n                        \"label_offset\": \"30px\",\n                        \"tick_format\": \"0d\",\n                        \"num_ticks\": da.sizes[\"band\"],\n                    }\n                axes_options = {\n                    \"x\": x_axis_options,\n                    \"y\": {\"label_offset\": \"35px\"},\n                }\n\n                if not stack_btn.value:\n                    plt.clear()\n                    plt.plot(\n                        da.coords[da.dims[0]].values,\n                        da.values,\n                        axes_options=axes_options,\n                    )\n                else:\n                    color = np.random.rand(\n                        3,\n                    )\n                    if \"wavelength\" in da.coords:\n                        xlabel = \"Wavelength (nm)\"\n                        x_values = da[\"wavelength\"].values\n                    else:\n                        xlabel = \"Band\"\n                        x_values = da.coords[da.dims[0]].values\n\n                    plt.plot(\n                        x_values,\n                        da.values,\n                        color=color,\n                        axes_options=axes_options,\n                    )\n                    try:\n                        if isinstance(self._fig.axes[0], bqplot.ColorAxis):\n                            self._fig.axes = self._fig.axes[1:]\n                        elif isinstance(self._fig.axes[-1], bqplot.ColorAxis):\n                            self._fig.axes = self._fig.axes[:-1]\n                    except Exception:\n                        pass\n\n                plt.xlabel(xlabel)\n                plt.ylabel(ylabel)\n                if xlim:\n                    plt.xlim(xlim[0], xlim[1])\n                if ylim:\n                    plt.ylim(ylim[0], ylim[1])\n\n                if not self._show_plot:\n                    with self._output_widget:\n                        plt.show()\n                        self._show_plot = True\n\n                self._host_map.default_style = {\"cursor\": \"crosshair\"}\n\n        self._host_map.on_interaction(handle_interaction)\n        self._on_map_interaction = handle_interaction\n\n        self._spectral_widget = self\n        self._spectral_control = ipyleaflet.WidgetControl(\n            widget=self, position=position\n        )\n        self._host_map.add(self._spectral_control)\n\n    def cleanup(self):\n        \"\"\"Removes the widget from the map and performs cleanup.\"\"\"\n        if self._host_map:\n            self._host_map.default_style = {\"cursor\": \"default\"}\n            self._host_map.on_interaction(self._on_map_interaction, remove=True)\n\n            if self._output_control:\n                self._host_map.remove_control(self._output_control)\n\n                if self._output_widget:\n                    self._output_widget.close()\n                    self._output_widget = None\n\n            if self._spectral_control:\n                self._host_map.remove_control(self._spectral_control)\n                self._spectral_control = None\n\n                if self._spectral_widget:\n                    self._spectral_widget.close()\n                    self._spectral_widget = None\n\n            if hasattr(self._host_map, \"_plot_marker_cluster\"):\n                self._host_map._plot_marker_cluster.markers = []\n                self._host_map._plot_markers = []\n\n            if hasattr(self._host_map, \"_spectral_data\"):\n                self._host_map._spectral_data = {}\n\n            if hasattr(self, \"_output_widget\") and self._output_widget is not None:\n                self._output_widget.clear_output()\n\n        if self.on_close is not None:\n            self.on_close()\n</code></pre>"},{"location":"gui/#prismatools.gui.spectralWidget.__init__","title":"<code>__init__(self, host_map, stack=True, position='topright', xlim=None, ylim=None, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a new instance of the SpectralWidget class.</p> <p>Parameters:</p> Name Type Description Default <code>host_map</code> <code>Map</code> <p>The map to host the widget.</p> required <code>stack</code> <code>bool</code> <p>Whether to stack the plots. Defaults to True.</p> <code>True</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <code>xlim</code> <code>tuple</code> <p>The x-axis limits. Defaults to None.</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>The y-axis limits. Defaults to None.</p> <code>None</code> Source code in <code>prismatools/gui.py</code> <pre><code>def __init__(\n    self, host_map, stack=True, position=\"topright\", xlim=None, ylim=None, **kwargs\n):\n    \"\"\"\n    Initializes a new instance of the SpectralWidget class.\n\n    Args:\n        host_map (Map): The map to host the widget.\n        stack (bool, optional): Whether to stack the plots. Defaults to True.\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n        xlim (tuple, optional): The x-axis limits. Defaults to None.\n        ylim (tuple, optional): The y-axis limits. Defaults to None.\n    \"\"\"\n    self._host_map = host_map\n    self.on_close = None\n    self._stack = stack\n    self._show_plot = False\n\n    fig_margin = {\"top\": 20, \"bottom\": 35, \"left\": 50, \"right\": 20}\n    fig = plt.figure(\n        # title=None,\n        fig_margin=fig_margin,\n        layout={\"width\": \"500px\", \"height\": \"300px\"},\n    )\n\n    self._fig = fig\n    self._host_map._fig = fig\n\n    layer_names = list(host_map.cog_layer_dict.keys())\n    layers_widget = widgets.Dropdown(options=layer_names)\n    layers_widget.layout.width = \"18ex\"\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    reset_btn = widgets.Button(\n        icon=\"trash\",\n        tooltip=\"Remove all markers\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    stack_btn = widgets.ToggleButton(\n        value=stack,\n        icon=\"area-chart\",\n        tooltip=\"Stack spectral signatures\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    def reset_btn_click(_):\n        if hasattr(self._host_map, \"_plot_marker_cluster\"):\n            self._host_map._plot_marker_cluster.markers = []\n            self._host_map._plot_markers = []\n\n        if hasattr(self._host_map, \"_spectral_data\"):\n            self._host_map._spectral_data = {}\n\n        self._output_widget.clear_output()\n        self._show_plot = False\n        plt.clear()\n\n    reset_btn.on_click(reset_btn_click)\n\n    save_btn = widgets.Button(\n        icon=\"floppy-o\",\n        tooltip=\"Save the data to a CSV\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    def chooser_callback(chooser):\n        if chooser.selected:\n            file_path = chooser.selected\n            self._host_map.spectral_to_csv(file_path)\n            if (\n                hasattr(self._host_map, \"_file_chooser_control\")\n                and self._host_map._file_chooser_control in self._host_map.controls\n            ):\n                self._host_map.remove_control(self._host_map._file_chooser_control)\n                self._host_map._file_chooser.close()\n\n    def save_btn_click(_):\n        if not hasattr(self._host_map, \"_spectral_data\"):\n            return\n\n        self._output_widget.clear_output()\n        file_chooser = FileChooser(\n            os.getcwd(), layout=widgets.Layout(width=\"454px\")\n        )\n        file_chooser.filter_pattern = \"*.csv\"\n        file_chooser.use_dir_icons = True\n        file_chooser.title = \"Save spectral data to a CSV file\"\n        file_chooser.default_filename = \"spectral_data.csv\"\n        file_chooser.show_hidden = False\n        file_chooser.register_callback(chooser_callback)\n        file_chooser_control = ipyleaflet.WidgetControl(\n            widget=file_chooser, position=\"topright\"\n        )\n        self._host_map.add(file_chooser_control)\n        setattr(self._host_map, \"_file_chooser\", file_chooser)\n        setattr(self._host_map, \"_file_chooser_control\", file_chooser_control)\n\n    save_btn.on_click(save_btn_click)\n\n    def close_widget(_):\n        self.cleanup()\n\n    close_btn.on_click(close_widget)\n\n    super().__init__([layers_widget, stack_btn, reset_btn, save_btn, close_btn])\n\n    output = widgets.Output()\n    output_control = ipyleaflet.WidgetControl(widget=output, position=\"bottomright\")\n    self._output_widget = output\n    self._output_control = output_control\n    self._host_map.add(output_control)\n\n    if not hasattr(self._host_map, \"_spectral_data\"):\n        self._host_map._spectral_data = {}\n\n    def handle_interaction(**kwargs):\n\n        latlon = kwargs.get(\"coordinates\")\n        lat = latlon[0]\n        lon = latlon[1]\n        if kwargs.get(\"type\") == \"click\" and self._host_map._layer_editor is None:\n            layer_name = layers_widget.value\n\n            if not hasattr(self._host_map, \"_plot_markers\"):\n                self._host_map._plot_markers = []\n            markers = self._host_map._plot_markers\n            marker_cluster = self._host_map._plot_marker_cluster\n            markers.append(ipyleaflet.Marker(location=latlon, draggable=False))\n            marker_cluster.markers = markers\n            self._host_map._plot_marker_cluster = marker_cluster\n\n            xlabel = \"Wavelength (nm)\"\n            ylabel = \"Reflectance\"\n\n            ds = self._host_map.cog_layer_dict[layer_name][\"xds\"]\n\n            if self._host_map.cog_layer_dict[layer_name][\"hyper\"] == \"PRISMA\":\n                da = extract_prisma(ds, lat, lon)\n\n            self._host_map._spectral_data[f\"({lat:.4f} {lon:.4f})\"] = da.values\n\n            if self._host_map.cog_layer_dict[layer_name][\"hyper\"] != \"XARRAY\":\n                da[da &lt; 0] = np.nan\n                x_axis_options = {\"label_offset\": \"30px\"}\n            else:\n                x_axis_options = {\n                    \"label_offset\": \"30px\",\n                    \"tick_format\": \"0d\",\n                    \"num_ticks\": da.sizes[\"band\"],\n                }\n            axes_options = {\n                \"x\": x_axis_options,\n                \"y\": {\"label_offset\": \"35px\"},\n            }\n\n            if not stack_btn.value:\n                plt.clear()\n                plt.plot(\n                    da.coords[da.dims[0]].values,\n                    da.values,\n                    axes_options=axes_options,\n                )\n            else:\n                color = np.random.rand(\n                    3,\n                )\n                if \"wavelength\" in da.coords:\n                    xlabel = \"Wavelength (nm)\"\n                    x_values = da[\"wavelength\"].values\n                else:\n                    xlabel = \"Band\"\n                    x_values = da.coords[da.dims[0]].values\n\n                plt.plot(\n                    x_values,\n                    da.values,\n                    color=color,\n                    axes_options=axes_options,\n                )\n                try:\n                    if isinstance(self._fig.axes[0], bqplot.ColorAxis):\n                        self._fig.axes = self._fig.axes[1:]\n                    elif isinstance(self._fig.axes[-1], bqplot.ColorAxis):\n                        self._fig.axes = self._fig.axes[:-1]\n                except Exception:\n                    pass\n\n            plt.xlabel(xlabel)\n            plt.ylabel(ylabel)\n            if xlim:\n                plt.xlim(xlim[0], xlim[1])\n            if ylim:\n                plt.ylim(ylim[0], ylim[1])\n\n            if not self._show_plot:\n                with self._output_widget:\n                    plt.show()\n                    self._show_plot = True\n\n            self._host_map.default_style = {\"cursor\": \"crosshair\"}\n\n    self._host_map.on_interaction(handle_interaction)\n    self._on_map_interaction = handle_interaction\n\n    self._spectral_widget = self\n    self._spectral_control = ipyleaflet.WidgetControl(\n        widget=self, position=position\n    )\n    self._host_map.add(self._spectral_control)\n</code></pre>"},{"location":"gui/#prismatools.gui.spectralWidget.cleanup","title":"<code>cleanup(self)</code>","text":"<p>Removes the widget from the map and performs cleanup.</p> Source code in <code>prismatools/gui.py</code> <pre><code>def cleanup(self):\n    \"\"\"Removes the widget from the map and performs cleanup.\"\"\"\n    if self._host_map:\n        self._host_map.default_style = {\"cursor\": \"default\"}\n        self._host_map.on_interaction(self._on_map_interaction, remove=True)\n\n        if self._output_control:\n            self._host_map.remove_control(self._output_control)\n\n            if self._output_widget:\n                self._output_widget.close()\n                self._output_widget = None\n\n        if self._spectral_control:\n            self._host_map.remove_control(self._spectral_control)\n            self._spectral_control = None\n\n            if self._spectral_widget:\n                self._spectral_widget.close()\n                self._spectral_widget = None\n\n        if hasattr(self._host_map, \"_plot_marker_cluster\"):\n            self._host_map._plot_marker_cluster.markers = []\n            self._host_map._plot_markers = []\n\n        if hasattr(self._host_map, \"_spectral_data\"):\n            self._host_map._spectral_data = {}\n\n        if hasattr(self, \"_output_widget\") and self._output_widget is not None:\n            self._output_widget.clear_output()\n\n    if self.on_close is not None:\n        self.on_close()\n</code></pre>"},{"location":"gui/#prismatools.gui.change_basemap","title":"<code>change_basemap(m, position='topright')</code>","text":"<p>Widget for changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map.</p> required Source code in <code>prismatools/gui.py</code> <pre><code>def change_basemap(m, position: Optional[str] = \"topright\"):\n    \"\"\"Widget for changing basemaps.\n\n    Args:\n        m (object): leafmap.Map.\n    \"\"\"\n    from leafmap.basemaps import get_xyz_dict\n    from leafmap import basemaps, get_basemap\n\n    xyz_dict = get_xyz_dict()\n\n    value = \"OpenStreetMap\"\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=value,\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n\n    def on_click(change):\n        if change[\"new\"]:\n            basemap_name = dropdown.value\n            if basemap_name not in m.get_layer_names():\n                m.add_basemap(basemap_name)\n                if basemap_name in xyz_dict:\n                    if \"bounds\" in xyz_dict[basemap_name]:\n                        bounds = xyz_dict[basemap_name][\"bounds\"]\n                        bounds = [\n                            bounds[0][1],\n                            bounds[0][0],\n                            bounds[1][1],\n                            bounds[1][0],\n                        ]\n                        m.zoom_to_bounds(bounds)\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        m.toolbar_reset()\n        if m.basemap_ctrl is not None and m.basemap_ctrl in m.controls:\n            m.remove_control(m.basemap_ctrl)\n        basemap_widget.close()\n\n    close_btn.on_click(close_click)\n\n    basemap_control = WidgetControl(widget=basemap_widget, position=position)\n    m.add(basemap_control)\n    m.basemap_ctrl = basemap_control\n</code></pre>"},{"location":"gui/#prismatools.gui.layer_manager_gui","title":"<code>layer_manager_gui(m, position='topright', opened=True, return_widget=False)</code>","text":"<p>Creates a layer manager widget.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>return_widget</code> <code>bool</code> <p>Whether to return the widget. Defaults to False.</p> <code>False</code> Source code in <code>prismatools/gui.py</code> <pre><code>def layer_manager_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    return_widget: Optional[bool] = False,\n):\n    \"\"\"Creates a layer manager widget.\n\n    Args:\n        m (geemap.Map): The geemap.Map object.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        return_widget (bool, optional): Whether to return the widget. Defaults to False.\n    \"\"\"\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layer Manager\",\n        icon=\"server\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [layers_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = []\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_header]\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [layers_button]\n\n    layers_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            layers_button.value = False\n            m.toolbar_reset()\n            if m.layer_manager is not None and m.layer_manager in m.controls:\n                m.remove_control(m.layer_manager)\n                m.layer_manager = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            layers_hbox = []\n            all_layers_chk = widgets.Checkbox(\n                value=False,\n                description=\"All layers on/off\",\n                indent=False,\n                layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n            )\n            all_layers_chk.layout.width = \"30ex\"\n            layers_hbox.append(all_layers_chk)\n\n            def all_layers_chk_changed(change):\n                if change[\"new\"]:\n                    for layer in m.layers:\n                        if hasattr(layer, \"visible\"):\n                            layer.visible = True\n                else:\n                    for layer in m.layers:\n                        if hasattr(layer, \"visible\"):\n                            layer.visible = False\n\n            all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n            layers = [lyr for lyr in m.layers if lyr.name]\n\n            # if the layers contain unsupported layers (e.g., GeoJSON, GeoData), adds the ipyleaflet built-in LayerControl\n            if len(layers) &lt; (len(m.layers) - 1):\n                if m.layer_control is None:\n                    layer_control = LayersControl(position=\"topright\")\n                    m.layer_control = layer_control\n                if m.layer_control not in m.controls:\n                    m.add(m.layer_control)\n\n            # for non-TileLayer, use layer.style={'opacity':0, 'fillOpacity': 0} to turn layer off.\n            for layer in layers:\n                visible = True\n                if hasattr(layer, \"visible\"):\n                    visible = layer.visible\n                layer_chk = widgets.Checkbox(\n                    value=visible,\n                    description=layer.name,\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\"),\n                )\n                layer_chk.layout.width = \"25ex\"\n\n                if layer in m.geojson_layers:\n                    try:\n                        opacity = max(\n                            layer.style[\"opacity\"], layer.style[\"fillOpacity\"]\n                        )\n                    except KeyError:\n                        opacity = 1.0\n                elif hasattr(layer, \"opacity\"):\n                    opacity = layer.opacity\n                else:\n                    opacity = 1.0\n\n                layer_opacity = widgets.FloatSlider(\n                    value=opacity,\n                    min=0,\n                    max=1,\n                    step=0.01,\n                    readout=False,\n                    layout=widgets.Layout(width=\"80px\"),\n                )\n                layer_settings = widgets.Button(\n                    icon=\"gear\",\n                    tooltip=layer.name,\n                    layout=widgets.Layout(\n                        width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 0px\"\n                    ),\n                )\n\n                def layer_settings_click(b):\n                    if b.tooltip in m.cog_layer_dict:\n                        m._add_layer_editor(\n                            position=\"topright\",\n                            layer_dict=m.cog_layer_dict[b.tooltip],\n                        )\n\n                layer_settings.on_click(layer_settings_click)\n\n                def layer_opacity_changed(change):\n                    if change[\"new\"]:\n                        layer.style = {\n                            \"opacity\": change[\"new\"],\n                            \"fillOpacity\": change[\"new\"],\n                        }\n\n                if hasattr(layer, \"visible\"):\n                    widgets.jslink((layer_chk, \"value\"), (layer, \"visible\"))\n\n                if layer in m.geojson_layers:\n                    layer_opacity.observe(layer_opacity_changed, \"value\")\n                elif hasattr(layer, \"opacity\"):\n                    widgets.jsdlink((layer_opacity, \"value\"), (layer, \"opacity\"))\n\n                hbox = widgets.HBox(\n                    [layer_chk, layer_settings, layer_opacity],\n                    layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                )\n                layers_hbox.append(hbox)\n                m.layer_widget = layers_hbox\n\n            toolbar_header.children = [close_button, layers_button]\n            toolbar_footer.children = layers_hbox\n\n        else:\n            toolbar_header.children = [layers_button]\n\n    layers_button.observe(layers_btn_click, \"value\")\n    layers_button.value = opened\n\n    if not hasattr(m, \"_layer_manager_widget\"):\n        m._layer_manager_widget = toolbar_footer\n\n    if return_widget:\n        return m.layer_widget\n    else:\n        layer_control = WidgetControl(widget=toolbar_widget, position=position)\n\n        if layer_control not in m.controls:\n            m.add_control(layer_control)\n            m.layer_manager = layer_control\n</code></pre>"},{"location":"gui/#prismatools.gui.main_toolbar","title":"<code>main_toolbar(m)</code>","text":"<p>Creates the main toolbar and adds it to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leafmap Map object.</p> required Source code in <code>prismatools/gui.py</code> <pre><code>def main_toolbar(m):\n    \"\"\"Creates the main toolbar and adds it to the map.\n\n    Args:\n        m (leafmap.Map): The leafmap Map object.\n    \"\"\"\n    # add here additional tools\n    all_tools = {\n        \"map\": {\n            \"name\": \"basemap\",\n            \"tooltip\": \"Change basemap\",\n        },\n    }\n\n    tools = {}\n    for tool in all_tools:\n        if os.environ.get(all_tools[tool][\"name\"].upper(), \"\").upper() != \"FALSE\":\n            tools[tool] = all_tools[tool]\n\n    icons = list(tools.keys())\n    tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n    toolnames = [item[\"name\"].upper() for item in list(all_tools.values())]\n    toolnames.sort()\n    setattr(m, \"_ENV_VARS\", toolnames)\n\n    icon_width = \"32px\"\n    icon_height = \"32px\"\n    n_cols = 3\n    n_rows = math.ceil(len(icons) / n_cols)\n\n    toolbar_grid = widgets.GridBox(\n        children=[\n            widgets.ToggleButton(\n                layout=widgets.Layout(\n                    width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                ),\n                button_style=\"primary\",\n                icon=icons[i],\n                tooltip=tooltips[i],\n            )\n            for i in range(len(icons))\n        ],\n        layout=widgets.Layout(\n            width=\"109px\",\n            grid_template_columns=(icon_width + \" \") * n_cols,\n            grid_template_rows=(icon_height + \" \") * n_rows,\n            grid_gap=\"1px 1px\",\n            padding=\"5px\",\n        ),\n    )\n    m.toolbar = toolbar_grid\n\n    def tool_callback(change):\n        if change[\"new\"]:\n            current_tool = change[\"owner\"]\n            for tool in toolbar_grid.children:\n                if tool is not current_tool:\n                    tool.value = False\n            tool = change[\"owner\"]\n            tool_name = tools[tool.icon][\"name\"]\n\n            if tool_name == \"basemap\":\n                change_basemap(m)\n        else:\n            # tool = change[\"owner\"]\n            # tool_name = tools[tool.icon][\"name\"]\n            pass\n\n        m.toolbar_reset()\n\n    for tool in toolbar_grid.children:\n        tool.observe(tool_callback, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    m.toolbar_button = toolbar_button\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layers\",\n        icon=\"server\",\n        layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n    )\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [layers_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [toolbar_grid]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                layers_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            layers_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not layers_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            toolbar_footer.children = layer_manager_gui(m, return_widget=True)\n            toolbar_button.value = False\n        else:\n            toolbar_footer.children = [toolbar_grid]\n\n    layers_button.observe(layers_btn_click, \"value\")\n\n    toolbar_control = WidgetControl(widget=toolbar_widget, position=\"topright\")\n\n    m.add(toolbar_control)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install prismatools, run this command in your terminal:</p> <pre><code>pip install prismatools\n</code></pre> <p>This is the preferred method to install prismatools, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install prismatools from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/gthlor/prismatools\n</code></pre>"},{"location":"prisma/","title":"prisma module","text":"<p>The prisma module provides functions to read and write PRISMA data products</p>"},{"location":"prisma/#prismatools.prisma.array_to_image","title":"<code>array_to_image(array, output, dtype=None, compress='lzw', transpose=True, crs=None, transform=None, driver='GTiff', **kwargs)</code>","text":"<p>Save a NumPy array as a georeferenced raster (GeoTIFF by default).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>Array to save. Shape can be (rows, cols) or (bands, rows, cols).</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <code>dtype</code> <code>np.dtype</code> <p>Data type for output. Auto-inferred if None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>Compression for GTiff/COG. Defaults to \"lzw\".</p> <code>'lzw'</code> <code>transpose</code> <code>bool</code> <p>If True, expects (bands, rows, cols) and transposes.</p> <code>True</code> <code>crs</code> <code>str</code> <p>CRS of the output raster.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>Affine transform of the raster.</p> <code>None</code> <code>driver</code> <code>str</code> <p>GDAL driver. Defaults to \"GTiff\".</p> <code>'GTiff'</code> <code>**kwargs</code> <p>Extra options for rasterio.open().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the saved file.</p> Source code in <code>prismatools/prisma.py</code> <pre><code>def array_to_image(\n    array: np.ndarray,\n    output: str,\n    dtype: Optional[np.dtype] = None,\n    compress: str = \"lzw\",\n    transpose: bool = True,\n    crs: Optional[str] = None,\n    transform: Optional[tuple] = None,\n    driver: str = \"GTiff\",\n    **kwargs,\n) -&gt; str:\n    \"\"\"\n    Save a NumPy array as a georeferenced raster (GeoTIFF by default).\n\n    Args:\n        array (np.ndarray): Array to save. Shape can be (rows, cols) or (bands, rows, cols).\n        output (str): Path to the output file.\n        dtype (np.dtype, optional): Data type for output. Auto-inferred if None.\n        compress (str, optional): Compression for GTiff/COG. Defaults to \"lzw\".\n        transpose (bool, optional): If True, expects (bands, rows, cols) and transposes.\n        crs (str, optional): CRS of the output raster.\n        transform (tuple, optional): Affine transform of the raster.\n        driver (str, optional): GDAL driver. Defaults to \"GTiff\".\n        **kwargs: Extra options for rasterio.open().\n\n    Returns:\n        str: Path to the saved file.\n    \"\"\"\n    # ensure correct shape\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    # ensure output directory exists\n    os.makedirs(os.path.dirname(os.path.abspath(output)), exist_ok=True)\n\n    # get driver from extension\n    ext = os.path.splitext(output)[-1].lower()\n    driver_map = {\"\": \"COG\", \".tif\": \"GTiff\", \".tiff\": \"GTiff\", \".dat\": \"ENVI\"}\n    driver = driver_map.get(ext, \"COG\")\n    if ext == \"\":\n        output += \".tif\"\n\n    # infer dtype if not given\n    if dtype is None:\n        min_val, max_val = np.nanmin(array), np.nanmax(array)\n        if min_val &gt;= 0 and max_val &lt;= 1:\n            dtype = np.float32\n        elif min_val &gt;= 0 and max_val &lt;= 255:\n            dtype = np.uint8\n        elif min_val &gt;= -128 and max_val &lt;= 127:\n            dtype = np.int8\n        elif min_val &gt;= 0 and max_val &lt;= 65535:\n            dtype = np.uint16\n        elif min_val &gt;= -32768 and max_val &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n    array = array.astype(dtype)\n\n    # set metadata\n    count = 1 if array.ndim == 2 else array.shape[2]\n    metadata = dict(\n        driver=driver,\n        height=array.shape[0],\n        width=array.shape[1],\n        count=count,\n        dtype=array.dtype,\n        crs=crs,\n        transform=transform,\n    )\n    if compress and driver in [\"GTiff\", \"COG\"]:\n        metadata[\"compress\"] = compress\n    metadata.update(**kwargs)\n\n    # write raster\n    with rasterio.open(output, \"w\", **metadata) as dst:\n        if array.ndim == 2:  # panchromatic\n            dst.write(array, 1)\n            dst.set_band_description(\n                1, kwargs.get(\"band_description\", \"Panchromatic band\")\n            )\n        else:  # hyperspectral\n            for i in range(array.shape[2]):\n                dst.write(array[:, :, i], i + 1)\n                if \"wavelengths\" in kwargs:\n                    wl = kwargs[\"wavelengths\"][i]\n                    dst.set_band_description(i + 1, f\"Band {i+1} ({wl:.1f} nm)\")\n\n    return output\n</code></pre>"},{"location":"prisma/#prismatools.prisma.extract_prisma","title":"<code>extract_prisma(dataset, lat, lon, offset=15.0)</code>","text":"<p>Extracts an averaged reflectance spectrum from a PRISMA hyperspectral dataset.</p> <p>A square spatial window is centered at the specified latitude and longitude, and the reflectance values within that window are averaged across the spatial dimensions to produce a single spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>xarray.Dataset</code> <p>The PRISMA dataset containing reflectance data, with valid CRS information.</p> required <code>lat</code> <code>float</code> <p>Latitude of the center point.</p> required <code>lon</code> <code>float</code> <p>Longitude of the center points.</p> required <code>offset</code> <code>float</code> <p>Half-size of the square window for extraction, expressed in the dataset's projected coordinate units (e.g., meters). Defaults to 15.0.</p> <code>15.0</code> <p>Returns:</p> Type Description <code>xarray.DataArray</code> <p>A 1D array containing the averaged reflectance values across wavelengths. If no matching pixels are found, returns NaN values.</p> Source code in <code>prismatools/prisma.py</code> <pre><code>def extract_prisma(\n    dataset: xr.Dataset,\n    lat: float,\n    lon: float,\n    offset: float = 15.0,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Extracts an averaged reflectance spectrum from a PRISMA hyperspectral dataset.\n\n    A square spatial window is centered at the specified latitude and longitude,\n    and the reflectance values within that window are averaged across the spatial\n    dimensions to produce a single spectrum.\n\n    Args:\n        dataset (xarray.Dataset): The PRISMA dataset containing reflectance data,\n            with valid CRS information.\n        lat (float): Latitude of the center point.\n        lon (float): Longitude of the center points.\n        offset (float, optional): Half-size of the square window for extraction,\n            expressed in the dataset's projected coordinate units (e.g., meters).\n            Defaults to 15.0.\n\n    Returns:\n        xarray.DataArray: A 1D array containing the averaged reflectance values\n        across wavelengths. If no matching pixels are found, returns NaN values.\n    \"\"\"\n    if dataset.rio.crs is None:\n        raise ValueError(\"Dataset CRS not set. Please provide dataset with CRS info.\")\n\n    crs = dataset.rio.crs.to_string()\n    # convert lat/lon to projected coords\n    x_proj, y_proj = convert_coords([(lat, lon)], \"epsg:4326\", crs)[0]\n\n    da = dataset[\"reflectance\"]\n    x_con = (da[\"x\"] &gt; x_proj - offset) &amp; (da[\"x\"] &lt; x_proj + offset)\n    y_con = (da[\"y\"] &gt; y_proj - offset) &amp; (da[\"y\"] &lt; y_proj + offset)\n\n    data = da.where(x_con &amp; y_con, drop=True)\n\n    if \"wavelength\" in da.dims:\n        data = data.mean(dim=[\"x\", \"y\"], skipna=True)\n        return xr.DataArray(\n            data,\n            dims=[\"wavelength\"],\n            coords={\"wavelength\": dataset.coords[\"wavelength\"]},\n        )\n    else:\n        # panchromatic\n        data = data.mean(dim=[\"x\", \"y\"], skipna=True)\n        return xr.DataArray(\n            [data.item()] if np.ndim(data) == 0 else data,\n            dims=[\"value\"],\n        )\n</code></pre>"},{"location":"prisma/#prismatools.prisma.read_prismaL2D","title":"<code>read_prismaL2D(file_path, wavelengths=None, method='nearest', panchromatic=False)</code>","text":"<p>Reads PRISMA Level-2D .he5 data (hyperspectral or panchromatic) and returns an xarray.Dataset with reflectance values and geospatial metadata.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the PRISMA L2D .he5 file.</p> required <code>wavelengths</code> <code>Optional[List[float]]</code> <p>List of wavelengths (in nm) to extract (only for hyperspectral cube). - If None, all valid wavelengths are used. - If provided, can select by exact match or nearest available wavelength.</p> <code>None</code> <code>method</code> <code>str, default \"nearest\"</code> <p>Method for wavelength selection (\"nearest\" or \"exact\").</p> <code>'nearest'</code> <code>panchromatic</code> <code>bool, default False</code> <p>If True, read the panchromatic cube.                                 If False, read the hyperspectral cube.</p> <code>False</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>An xarray.Dataset containing reflectance data with coordinates.</p> Source code in <code>prismatools/prisma.py</code> <pre><code>def read_prismaL2D(\n    file_path: str,\n    wavelengths: Optional[List[float]] = None,\n    method: str = \"nearest\",\n    panchromatic: bool = False,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Reads PRISMA Level-2D .he5 data (hyperspectral or panchromatic)\n    and returns an xarray.Dataset with reflectance values and geospatial metadata.\n\n    Args:\n        file_path (str): Path to the PRISMA L2D .he5 file.\n        wavelengths (Optional[List[float]]): List of wavelengths (in nm) to extract\n            (only for hyperspectral cube).\n            - If None, all valid wavelengths are used.\n            - If provided, can select by exact match or nearest available wavelength.\n        method (str, default \"nearest\"): Method for wavelength selection (\"nearest\" or \"exact\").\n        panchromatic (bool, default False): If True, read the panchromatic cube.\n                                            If False, read the hyperspectral cube.\n\n    Returns:\n        xr.Dataset: An xarray.Dataset containing reflectance data with coordinates.\n    \"\"\"\n    # check if file is valid\n    if not check_valid_file(file_path, type=\"PRS_L2D\"):\n        raise ValueError(\n            f\"The file {file_path} is not a valid PRS_L2D file or does not exist.\"\n        )\n\n    try:\n        with h5py.File(file_path, \"r\") as f:\n            epsg_code = f.attrs[\"Epsg_Code\"][()]\n            ul_easting = f.attrs[\"Product_ULcorner_easting\"][()]\n            ul_northing = f.attrs[\"Product_ULcorner_northing\"][()]\n\n            if panchromatic:\n                # --- PANCHROMATIC ---\n                pancube_path = \"HDFEOS/SWATHS/PRS_L2D_PCO/Data Fields/Cube\"\n                pancube_data = f[pancube_path][()]\n                l2_scale_pan_min = f.attrs[\"L2ScalePanMin\"][()]\n                l2_scale_pan_max = f.attrs[\"L2ScalePanMax\"][()]\n                fill_value = -9999\n                max_data_value = 65535\n\n                pancube_data = l2_scale_pan_min + (\n                    pancube_data.astype(np.float32) / max_data_value\n                ) * (l2_scale_pan_max - l2_scale_pan_min)\n                pancube_data[pancube_data == fill_value] = np.nan\n\n                rows, cols = pancube_data.shape\n                transform = get_transform(ul_easting, ul_northing, res=5)\n                x_coords = np.array([transform * (i, 0) for i in range(cols)])[:, 0]\n                y_coords = np.array([transform * (0, j) for j in range(rows)])[:, 1]\n\n                ds = xr.Dataset(\n                    data_vars=dict(\n                        reflectance=(\n                            [\"y\", \"x\"],\n                            pancube_data,\n                            dict(\n                                units=\"unitless\",\n                                _FillValue=np.nan,\n                                standard_name=\"reflectance\",\n                                long_name=\"Panchromatic reflectance\",\n                            ),\n                        ),\n                    ),\n                    coords=dict(\n                        y=([\"y\"], y_coords, dict(units=\"m\")),\n                        x=([\"x\"], x_coords, dict(units=\"m\")),\n                    ),\n                )\n\n            else:\n                # --- HYPERSPECTRAL CUBE ---\n                swir_cube = f[\"HDFEOS/SWATHS/PRS_L2D_HCO/Data Fields/SWIR_Cube\"][()]\n                vnir_cube = f[\"HDFEOS/SWATHS/PRS_L2D_HCO/Data Fields/VNIR_Cube\"][()]\n                vnir_wavelengths = f.attrs[\"List_Cw_Vnir\"][()]\n                swir_wavelengths = f.attrs[\"List_Cw_Swir\"][()]\n                l2_scale_vnir_min = f.attrs[\"L2ScaleVnirMin\"][()]\n                l2_scale_vnir_max = f.attrs[\"L2ScaleVnirMax\"][()]\n                l2_scale_swir_min = f.attrs[\"L2ScaleSwirMin\"][()]\n                l2_scale_swir_max = f.attrs[\"L2ScaleSwirMax\"][()]\n                fill_value = -9999\n                max_data_value = 65535\n\n                vnir_cube = l2_scale_vnir_min + (\n                    vnir_cube.astype(np.float32) / max_data_value\n                ) * (l2_scale_vnir_max - l2_scale_vnir_min)\n                swir_cube = l2_scale_swir_min + (\n                    swir_cube.astype(np.float32) / max_data_value\n                ) * (l2_scale_swir_max - l2_scale_swir_min)\n\n                vnir_cube[vnir_cube == fill_value] = np.nan\n                swir_cube[swir_cube == fill_value] = np.nan\n\n                full_cube = np.concatenate((vnir_cube, swir_cube), axis=1)\n                full_wavelengths = np.concatenate((vnir_wavelengths, swir_wavelengths))\n\n                # filter and sort wavelengths\n                valid_idx = full_wavelengths &gt; 0\n                full_wavelengths = full_wavelengths[valid_idx]\n                full_cube = full_cube[:, valid_idx, :]\n                sort_idx = np.argsort(full_wavelengths)\n                full_wavelengths = full_wavelengths[sort_idx]\n                full_cube = full_cube[:, sort_idx, :]\n\n                # select requested wavelengths\n                if wavelengths is not None:\n                    requested = np.array(wavelengths)\n                    if method == \"exact\":\n                        idx = np.where(np.isin(full_wavelengths, requested))[0]\n                        if len(idx) == 0:\n                            raise ValueError(\n                                \"No requested wavelengths found (exact match).\"\n                            )\n                    else:\n                        idx = np.array(\n                            [np.abs(full_wavelengths - w).argmin() for w in requested]\n                        )\n                    full_wavelengths = full_wavelengths[idx]\n                    full_cube = full_cube[:, idx, :]\n\n                rows, cols = full_cube.shape[0], full_cube.shape[2]\n                transform = get_transform(ul_easting, ul_northing, res=30)\n                x_coords = np.array([transform * (i, 0) for i in range(cols)])[:, 0]\n                y_coords = np.array([transform * (0, j) for j in range(rows)])[:, 1]\n\n                ds = xr.Dataset(\n                    data_vars=dict(\n                        reflectance=(\n                            [\"y\", \"wavelength\", \"x\"],\n                            full_cube,\n                            dict(\n                                units=\"unitless\",\n                                _FillValue=np.nan,\n                                standard_name=\"reflectance\",\n                                long_name=\"Combined atmospherically corrected surface reflectance\",\n                            ),\n                        ),\n                    ),\n                    coords=dict(\n                        wavelength=(\n                            [\"wavelength\"],\n                            full_wavelengths,\n                            dict(long_name=\"center wavelength\", units=\"nm\"),\n                        ),\n                        y=([\"y\"], y_coords, dict(units=\"m\")),\n                        x=([\"x\"], x_coords, dict(units=\"m\")),\n                    ),\n                )\n                ds[\"reflectance\"] = ds.reflectance.transpose(\"y\", \"x\", \"wavelength\")\n\n    except Exception as e:\n        raise RuntimeError(f\"Error reading the file {file_path}: {e}\")\n\n    # write CRS and transform\n    crs = f\"EPSG:{epsg_code}\"\n    ds.rio.write_crs(crs, inplace=True)\n    ds.rio.write_transform(transform, inplace=True)\n\n    # global attributes\n    ds.attrs.update(\n        dict(\n            units=\"unitless\",\n            _FillValue=-9999,\n            grid_mapping=\"crs\",\n            standard_name=\"reflectance\",\n            Conventions=\"CF-1.6\",\n            crs=ds.rio.crs.to_string(),\n        )\n    )\n\n    return ds\n</code></pre>"},{"location":"prisma/#prismatools.prisma.write_prismaL2D","title":"<code>write_prismaL2D(dataset, output, panchromatic=False, wavelengths=None, method='nearest', **kwargs)</code>","text":"<p>Converts a PRISMA hyperspectral dataset to a georeferenced image.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Union[xr.Dataset, str]</code> <p>The PRISMA dataset or the path to the dataset file (.he5).</p> required <code>output</code> <code>str</code> <p>File path to save the output raster.</p> required <code>panchromatic</code> <code>bool</code> <p>If True, treat array as single-band pancromatic. Defaults to False.</p> <code>False</code> <code>wavelengths</code> <code>np.ndarray</code> <p>Wavelengths to select from the dataset. If None, all wavelengths are included. Defaults to None.</p> <code>None</code> <code>method</code> <code>str</code> <p>Method to use for wavelength selection (e.g. \"nearest\").</p> <code>'nearest'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to 'array_to_image()' and to 'rasterio.open()'.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Output file path, or None if all values are NaN.</p> Source code in <code>prismatools/prisma.py</code> <pre><code>def write_prismaL2D(\n    dataset: Union[xr.Dataset, str],\n    output: str,\n    panchromatic: bool = False,\n    wavelengths: Optional[np.ndarray] = None,\n    method: str = \"nearest\",\n    **kwargs: Any,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts a PRISMA hyperspectral dataset to a georeferenced image.\n\n    Args:\n        dataset (Union[xr.Dataset, str]): The PRISMA dataset or the path to the\n            dataset file (.he5).\n        output (str): File path to save the output raster.\n        panchromatic (bool, optional): If True, treat array as single-band pancromatic. Defaults to False.\n        wavelengths (np.ndarray, optional): Wavelengths to select from the dataset.\n            If None, all wavelengths are included. Defaults to None.\n        method (str, optional): Method to use for wavelength selection (e.g. \"nearest\").\n        **kwargs (Any): Additional arguments passed to 'array_to_image()' and to 'rasterio.open()'.\n\n    Returns:\n        str: Output file path, or None if all values are NaN.\n    \"\"\"\n    # load dataset if it's a path to .he5\n    if isinstance(dataset, str):\n        dataset = read_prismaL2D(dataset, panchromatic=panchromatic)\n\n    # get np.array\n    array = dataset[\"reflectance\"].values\n    if not np.any(np.isfinite(array)):\n        print(\"Warning: All reflectance values are NaN. Output image will be blank.\")\n        return None\n\n    # get band names (wavelength) and, eventually, select specific bands\n    if array.ndim == 2:  # panchromatic\n        kwargs[\"band_description\"] = \"Panchromatic band\"\n    else:  # cube\n        if wavelengths is not None:\n            dataset = dataset.sel(wavelength=wavelengths, method=method)\n            array = dataset[\"reflectance\"].values\n        kwargs[\"wavelengths\"] = dataset[\"wavelength\"].values\n\n    return array_to_image(\n        array,\n        output=output,\n        transpose=False,\n        crs=dataset.rio.crs,\n        transform=dataset.rio.transform(),\n        **kwargs,\n    )\n</code></pre>"},{"location":"prismatools/","title":"prismatools module","text":"<p>Main module.</p>"},{"location":"prismatools/#prismatools.prismatools.Map","title":"<code> Map            (Map)         </code>","text":"<p>A class that extends leafmap.Map to provide additional functionality for     prismatools.</p> <p>Methods</p> <p>Any methods inherited from leafmap.Map.</p> Source code in <code>prismatools/prismatools.py</code> <pre><code>class Map(leafmap.Map):\n    \"\"\"\n    A class that extends leafmap.Map to provide additional functionality for\n        prismatools.\n\n    Attributes:\n        Any attributes inherited from leafmap.Map.\n\n    Methods:\n        Any methods inherited from leafmap.Map.\n    \"\"\"\n\n    def __init__(self, center=[0, 0], zoom=2, **kwargs):\n        \"\"\"\n        Initializes a new instance of the Map class.\n\n        Args:\n            **kwargs: Arbitrary keyword arguments that are passed to the parent\n                class's constructor.\n        \"\"\"\n        # set off toolbars not needed from Leafmap\n        kwargs[\"layers_control\"] = False\n        kwargs[\"fullscreen_control\"] = True\n        kwargs[\"search_control\"] = False\n        kwargs[\"draw_control\"] = False\n        kwargs[\"measure_control\"] = False\n        kwargs[\"scale_control\"] = True\n        kwargs[\"toolbar_control\"] = False\n\n        super().__init__(**kwargs)\n        # add my simplified toolbar\n        main_toolbar(self)\n\n        self._spectral_data = {}\n        self._plot_options = None\n\n    def add(self, obj, position=\"topright\", xlim=None, ylim=None, **kwargs):\n        \"\"\"Add a layer to the map.\n\n        Args:\n            obj (str or object): The name of the layer or a layer object.\n            position (str, optional): The position of the layer widget. Can be\n                'topright', 'topleft', 'bottomright', or 'bottomleft'. Defaults\n                to 'topright'.\n            xlim (tuple, optional): The x-axis limits of the plot. Defaults to None.\n            ylim (tuple, optional): The y-axis limits of the plot. Defaults to None.\n            **kwargs: Arbitrary keyword arguments that are passed to the parent\n                class's add_layer method.\n        \"\"\"\n\n        if isinstance(obj, str):\n            if obj == \"spectral\":\n\n                spectralWidget(self, position=position, xlim=xlim, ylim=ylim, **kwargs)\n                self.set_plot_options(add_marker_cluster=True)\n            else:\n                super().add(obj, **kwargs)\n\n        else:\n            super().add(obj, **kwargs)\n\n    def add_prisma(\n        self,\n        source,\n        wavelengths=None,\n        indexes=None,\n        colormap=None,\n        vmin=0,\n        vmax=0.5,\n        nodata=np.nan,\n        attribution=None,\n        layer_name=\"PRISMA\",\n        zoom_to_layer=True,\n        visible=True,\n        array_args=None,\n        method=\"nearest\",\n        **kwargs,\n    ):\n        \"\"\"Add a PRISMA dataset to the map.\n\n        This function reads a PRISMA hyperspectral dataset, optionally selects\n        specific wavelengths, converts the data to an image, and adds it as a\n        raster layer to the map. The dataset can be provided as a file path or\n        as an xarray Dataset.\n\n        Args:\n            source (str or xarray.Dataset): The path to the PRISMA file or an\n                in-memory xarray Dataset containing PRISMA data.\n            wavelengths (list or np.ndarray, optional): Specific wavelengths to\n                select from the dataset. If None, all wavelengths are used.\n                Defaults to None.\n            indexes (int or list, optional): The band(s) to display. Band\n                indexing starts at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib`\n                to use when plotting a single band. See:\n                https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n                Default is greyscale.\n            vmin (float, optional): The minimum value for color mapping when\n                plotting a single band. Defaults to 0.\n            vmax (float, optional): The maximum value for color mapping when\n                plotting a single band. Defaults to 0.5.\n            nodata (float, optional): Value in the raster to interpret as\n                no-data. Defaults to np.nan.\n            attribution (str, optional): Attribution for the source raster.\n                Defaults to None.\n            layer_name (str, optional): The name to assign to the map layer.\n                Defaults to \"PRISMA\".\n            zoom_to_layer (bool, optional): Whether to zoom the map to the\n                extent of the layer after adding it. Defaults to True.\n            visible (bool, optional): Whether the layer should be visible when\n                first added. Defaults to True.\n            array_args (dict, optional): Additional keyword arguments to pass to\n                `array_to_memory_file` when reading the raster. Defaults to {}.\n            method (str, optional): Method to use for wavelength interpolation\n                when selecting bands. Options may include \"nearest\", \"linear\",\n                etc. Defaults to \"nearest\".\n            **kwargs: Additional keyword arguments passed to `add_raster`.\n        \"\"\"\n        if array_args is None:\n            array_args = {}\n\n        if isinstance(source, str):\n            xds = read_prismaL2D(source)\n        else:\n            xds = source\n\n        with tempfile.NamedTemporaryFile(suffix=\".tif\", delete=False) as tmp:\n            temp_path = tmp.name\n\n        # create a temporary .tif with only selected wavelengths because leafmap (built on ipyleaflet) can add only images with 3 bands or 1 band\n        write_prismaL2D(xds, wavelengths=wavelengths, method=method, output=temp_path)\n\n        self.add_raster(  # this function will add the tiff to the map\n            temp_path,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            zoom_to_layer=zoom_to_layer,\n            visible=visible,\n            array_args=array_args,\n            **kwargs,\n        )\n\n        self.cog_layer_dict[layer_name][\n            \"xds\"\n        ] = xds  # avoid losing spectral information\n        self.cog_layer_dict[layer_name][\"hyper\"] = \"PRISMA\"\n\n    def add_raster(\n        self,\n        source,\n        indexes=None,\n        colormap=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"Raster\",\n        layer_index=None,\n        zoom_to_layer=True,\n        visible=True,\n        opacity=1.0,\n        array_args=None,\n        client_args={\"cors_all\": False},\n        open_args=None,\n        **kwargs,\n    ):\n        \"\"\"Add a local raster dataset to the map.\n            If you are using this function in JupyterHub on a remote server\n                (e.g., Binder, Microsoft Planetary Computer) and\n            if the raster does not render properly, try installing\n                jupyter-server-proxy using `pip install jupyter-server-proxy`,\n            then running the following code before calling this function. For\n                more info, see https://bit.ly/3JbmF93.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud\n                Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts\n                at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib`\n                to use when plotting a single band. See\n                https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n                Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping\n                the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping\n                the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret\n                as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This\n                defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n            layer_index (int, optional): The index of the layer. Defaults to None.\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the\n                layer. Defaults to True.\n            visible (bool, optional): Whether the layer is visible. Defaults to\n                True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            array_args (dict, optional): Additional arguments to pass to\n                `array_to_memory_file` when reading the raster. Defaults to {}.\n            client_args (dict, optional): Additional arguments to pass to\n                localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n            open_args (dict, optional): Additional arguments to pass to\n                rioxarray.open_rasterio.\n\n        \"\"\"\n        import rioxarray as rxr\n\n        if array_args is None:\n            array_args = {}\n        if open_args is None:\n            open_args = {}\n\n        if nodata is None:\n            nodata = np.nan\n\n        super().add_raster(\n            source,\n            indexes=indexes,  # if source has more bands, you need to specify 3 indices\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            layer_index=layer_index,\n            zoom_to_layer=zoom_to_layer,\n            visible=visible,\n            opacity=opacity,\n            array_args=array_args,\n            client_args=client_args,\n            **kwargs,\n        )\n\n        if isinstance(source, str):\n            da = rxr.open_rasterio(source, **open_args)\n            dims = da.dims\n            da = da.transpose(dims[1], dims[2], dims[0])\n\n            xds = da.to_dataset(name=\"data\")\n            self.cog_layer_dict[layer_name][\"xds\"] = xds\n\n    def spectral_to_df(self, **kwargs):\n        \"\"\"Converts the spectral data to a pandas DataFrame.\n\n        Returns:\n            pd.DataFrame: The spectral data as a pandas DataFrame.\n        \"\"\"\n        import pandas as pd\n\n        df = pd.DataFrame(self._spectral_data, **kwargs)\n        return df\n\n    def spectral_to_csv(self, filename, index=True, **kwargs):\n        \"\"\"Saves the spectral data to a CSV file.\n\n        Args:\n            filename (str): The output CSV file.\n            index (bool, optional): Whether to write the index. Defaults to True.\n        \"\"\"\n        df = self.spectral_to_df()\n        df = df.rename_axis(\"band\")\n        df.to_csv(filename, index=index, **kwargs)\n\n    def set_plot_options(\n        self,\n        add_marker_cluster=False,\n        plot_type=None,\n        overlay=False,\n        position=\"bottomright\",\n        min_width=None,\n        max_width=None,\n        min_height=None,\n        max_height=None,\n        **kwargs,\n    ):\n        \"\"\"Sets plotting options.\n\n        Args:\n            add_marker_cluster (bool, optional): Whether to add a marker cluster.\n                Defaults to False.\n            sample_scale (float, optional):  A nominal scale in meters of the\n                projection to sample in . Defaults to None.\n            plot_type (str, optional): The plot type can be one of \"None\", \"bar\",\n                \"scatter\" or \"hist\". Defaults to None.\n            overlay (bool, optional): Whether to overlay plotted lines on the\n                figure. Defaults to False.\n            position (str, optional): Position of the control, can be\n                \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults\n                to 'bottomright'.\n            min_width (int, optional): Min width of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n            max_width (int, optional): Max width of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n            min_height (int, optional): Min height of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n            max_height (int, optional): Max height of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n\n        \"\"\"\n        plot_options_dict = {}\n        plot_options_dict[\"add_marker_cluster\"] = add_marker_cluster\n        plot_options_dict[\"plot_type\"] = plot_type\n        plot_options_dict[\"overlay\"] = overlay\n        plot_options_dict[\"position\"] = position\n        plot_options_dict[\"min_width\"] = min_width\n        plot_options_dict[\"max_width\"] = max_width\n        plot_options_dict[\"min_height\"] = min_height\n        plot_options_dict[\"max_height\"] = max_height\n\n        for key in kwargs:\n            plot_options_dict[key] = kwargs[key]\n\n        self._plot_options = plot_options_dict\n\n        if not hasattr(self, \"_plot_marker_cluster\"):\n            self._plot_marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n\n        if add_marker_cluster and (self._plot_marker_cluster not in self.layers):\n            self.add(self._plot_marker_cluster)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.__init__","title":"<code>__init__(self, center=[0, 0], zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a new instance of the Map class.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments that are passed to the parent class's constructor.</p> <code>{}</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def __init__(self, center=[0, 0], zoom=2, **kwargs):\n    \"\"\"\n    Initializes a new instance of the Map class.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments that are passed to the parent\n            class's constructor.\n    \"\"\"\n    # set off toolbars not needed from Leafmap\n    kwargs[\"layers_control\"] = False\n    kwargs[\"fullscreen_control\"] = True\n    kwargs[\"search_control\"] = False\n    kwargs[\"draw_control\"] = False\n    kwargs[\"measure_control\"] = False\n    kwargs[\"scale_control\"] = True\n    kwargs[\"toolbar_control\"] = False\n\n    super().__init__(**kwargs)\n    # add my simplified toolbar\n    main_toolbar(self)\n\n    self._spectral_data = {}\n    self._plot_options = None\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.add","title":"<code>add(self, obj, position='topright', xlim=None, ylim=None, **kwargs)</code>","text":"<p>Add a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or object</code> <p>The name of the layer or a layer object.</p> required <code>position</code> <code>str</code> <p>The position of the layer widget. Can be 'topright', 'topleft', 'bottomright', or 'bottomleft'. Defaults to 'topright'.</p> <code>'topright'</code> <code>xlim</code> <code>tuple</code> <p>The x-axis limits of the plot. Defaults to None.</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>The y-axis limits of the plot. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments that are passed to the parent class's add_layer method.</p> <code>{}</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def add(self, obj, position=\"topright\", xlim=None, ylim=None, **kwargs):\n    \"\"\"Add a layer to the map.\n\n    Args:\n        obj (str or object): The name of the layer or a layer object.\n        position (str, optional): The position of the layer widget. Can be\n            'topright', 'topleft', 'bottomright', or 'bottomleft'. Defaults\n            to 'topright'.\n        xlim (tuple, optional): The x-axis limits of the plot. Defaults to None.\n        ylim (tuple, optional): The y-axis limits of the plot. Defaults to None.\n        **kwargs: Arbitrary keyword arguments that are passed to the parent\n            class's add_layer method.\n    \"\"\"\n\n    if isinstance(obj, str):\n        if obj == \"spectral\":\n\n            spectralWidget(self, position=position, xlim=xlim, ylim=ylim, **kwargs)\n            self.set_plot_options(add_marker_cluster=True)\n        else:\n            super().add(obj, **kwargs)\n\n    else:\n        super().add(obj, **kwargs)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.add_prisma","title":"<code>add_prisma(self, source, wavelengths=None, indexes=None, colormap=None, vmin=0, vmax=0.5, nodata=nan, attribution=None, layer_name='PRISMA', zoom_to_layer=True, visible=True, array_args=None, method='nearest', **kwargs)</code>","text":"<p>Add a PRISMA dataset to the map.</p> <p>This function reads a PRISMA hyperspectral dataset, optionally selects specific wavelengths, converts the data to an image, and adds it as a raster layer to the map. The dataset can be provided as a file path or as an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str or xarray.Dataset</code> <p>The path to the PRISMA file or an in-memory xarray Dataset containing PRISMA data.</p> required <code>wavelengths</code> <code>list or np.ndarray</code> <p>Specific wavelengths to select from the dataset. If None, all wavelengths are used. Defaults to None.</p> <code>None</code> <code>indexes</code> <code>int or list</code> <p>The band(s) to display. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See: https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value for color mapping when plotting a single band. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value for color mapping when plotting a single band. Defaults to 0.5.</p> <code>0.5</code> <code>nodata</code> <code>float</code> <p>Value in the raster to interpret as no-data. Defaults to np.nan.</p> <code>nan</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The name to assign to the map layer. Defaults to \"PRISMA\".</p> <code>'PRISMA'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom the map to the extent of the layer after adding it. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer should be visible when first added. Defaults to True.</p> <code>True</code> <code>array_args</code> <code>dict</code> <p>Additional keyword arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>None</code> <code>method</code> <code>str</code> <p>Method to use for wavelength interpolation when selecting bands. Options may include \"nearest\", \"linear\", etc. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>add_raster</code>.</p> <code>{}</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def add_prisma(\n    self,\n    source,\n    wavelengths=None,\n    indexes=None,\n    colormap=None,\n    vmin=0,\n    vmax=0.5,\n    nodata=np.nan,\n    attribution=None,\n    layer_name=\"PRISMA\",\n    zoom_to_layer=True,\n    visible=True,\n    array_args=None,\n    method=\"nearest\",\n    **kwargs,\n):\n    \"\"\"Add a PRISMA dataset to the map.\n\n    This function reads a PRISMA hyperspectral dataset, optionally selects\n    specific wavelengths, converts the data to an image, and adds it as a\n    raster layer to the map. The dataset can be provided as a file path or\n    as an xarray Dataset.\n\n    Args:\n        source (str or xarray.Dataset): The path to the PRISMA file or an\n            in-memory xarray Dataset containing PRISMA data.\n        wavelengths (list or np.ndarray, optional): Specific wavelengths to\n            select from the dataset. If None, all wavelengths are used.\n            Defaults to None.\n        indexes (int or list, optional): The band(s) to display. Band\n            indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib`\n            to use when plotting a single band. See:\n            https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n            Default is greyscale.\n        vmin (float, optional): The minimum value for color mapping when\n            plotting a single band. Defaults to 0.\n        vmax (float, optional): The maximum value for color mapping when\n            plotting a single band. Defaults to 0.5.\n        nodata (float, optional): Value in the raster to interpret as\n            no-data. Defaults to np.nan.\n        attribution (str, optional): Attribution for the source raster.\n            Defaults to None.\n        layer_name (str, optional): The name to assign to the map layer.\n            Defaults to \"PRISMA\".\n        zoom_to_layer (bool, optional): Whether to zoom the map to the\n            extent of the layer after adding it. Defaults to True.\n        visible (bool, optional): Whether the layer should be visible when\n            first added. Defaults to True.\n        array_args (dict, optional): Additional keyword arguments to pass to\n            `array_to_memory_file` when reading the raster. Defaults to {}.\n        method (str, optional): Method to use for wavelength interpolation\n            when selecting bands. Options may include \"nearest\", \"linear\",\n            etc. Defaults to \"nearest\".\n        **kwargs: Additional keyword arguments passed to `add_raster`.\n    \"\"\"\n    if array_args is None:\n        array_args = {}\n\n    if isinstance(source, str):\n        xds = read_prismaL2D(source)\n    else:\n        xds = source\n\n    with tempfile.NamedTemporaryFile(suffix=\".tif\", delete=False) as tmp:\n        temp_path = tmp.name\n\n    # create a temporary .tif with only selected wavelengths because leafmap (built on ipyleaflet) can add only images with 3 bands or 1 band\n    write_prismaL2D(xds, wavelengths=wavelengths, method=method, output=temp_path)\n\n    self.add_raster(  # this function will add the tiff to the map\n        temp_path,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        zoom_to_layer=zoom_to_layer,\n        visible=visible,\n        array_args=array_args,\n        **kwargs,\n    )\n\n    self.cog_layer_dict[layer_name][\n        \"xds\"\n    ] = xds  # avoid losing spectral information\n    self.cog_layer_dict[layer_name][\"hyper\"] = \"PRISMA\"\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.add_raster","title":"<code>add_raster(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Raster', layer_index=None, zoom_to_layer=True, visible=True, opacity=1.0, array_args=None, client_args={'cors_all': False}, open_args=None, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server         (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try installing         jupyter-server-proxy using <code>pip install jupyter-server-proxy</code>,     then running the following code before calling this function. For         more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>layer_index</code> <code>int</code> <p>The index of the layer. Defaults to None.</p> <code>None</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>None</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.</p> <code>{'cors_all': False}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rioxarray.open_rasterio.</p> <code>None</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"Raster\",\n    layer_index=None,\n    zoom_to_layer=True,\n    visible=True,\n    opacity=1.0,\n    array_args=None,\n    client_args={\"cors_all\": False},\n    open_args=None,\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server\n            (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try installing\n            jupyter-server-proxy using `pip install jupyter-server-proxy`,\n        then running the following code before calling this function. For\n            more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud\n            Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts\n            at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib`\n            to use when plotting a single band. See\n            https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n            Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping\n            the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping\n            the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret\n            as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This\n            defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        layer_index (int, optional): The index of the layer. Defaults to None.\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the\n            layer. Defaults to True.\n        visible (bool, optional): Whether the layer is visible. Defaults to\n            True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        array_args (dict, optional): Additional arguments to pass to\n            `array_to_memory_file` when reading the raster. Defaults to {}.\n        client_args (dict, optional): Additional arguments to pass to\n            localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n        open_args (dict, optional): Additional arguments to pass to\n            rioxarray.open_rasterio.\n\n    \"\"\"\n    import rioxarray as rxr\n\n    if array_args is None:\n        array_args = {}\n    if open_args is None:\n        open_args = {}\n\n    if nodata is None:\n        nodata = np.nan\n\n    super().add_raster(\n        source,\n        indexes=indexes,  # if source has more bands, you need to specify 3 indices\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        layer_index=layer_index,\n        zoom_to_layer=zoom_to_layer,\n        visible=visible,\n        opacity=opacity,\n        array_args=array_args,\n        client_args=client_args,\n        **kwargs,\n    )\n\n    if isinstance(source, str):\n        da = rxr.open_rasterio(source, **open_args)\n        dims = da.dims\n        da = da.transpose(dims[1], dims[2], dims[0])\n\n        xds = da.to_dataset(name=\"data\")\n        self.cog_layer_dict[layer_name][\"xds\"] = xds\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.set_plot_options","title":"<code>set_plot_options(self, add_marker_cluster=False, plot_type=None, overlay=False, position='bottomright', min_width=None, max_width=None, min_height=None, max_height=None, **kwargs)</code>","text":"<p>Sets plotting options.</p> <p>Parameters:</p> Name Type Description Default <code>add_marker_cluster</code> <code>bool</code> <p>Whether to add a marker cluster. Defaults to False.</p> <code>False</code> <code>sample_scale</code> <code>float</code> <p>A nominal scale in meters of the projection to sample in . Defaults to None.</p> required <code>plot_type</code> <code>str</code> <p>The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay plotted lines on the figure. Defaults to False.</p> <code>False</code> <code>position</code> <code>str</code> <p>Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>min_width</code> <code>int</code> <p>Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_width</code> <code>int</code> <p>Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>min_height</code> <code>int</code> <p>Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_height</code> <code>int</code> <p>Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def set_plot_options(\n    self,\n    add_marker_cluster=False,\n    plot_type=None,\n    overlay=False,\n    position=\"bottomright\",\n    min_width=None,\n    max_width=None,\n    min_height=None,\n    max_height=None,\n    **kwargs,\n):\n    \"\"\"Sets plotting options.\n\n    Args:\n        add_marker_cluster (bool, optional): Whether to add a marker cluster.\n            Defaults to False.\n        sample_scale (float, optional):  A nominal scale in meters of the\n            projection to sample in . Defaults to None.\n        plot_type (str, optional): The plot type can be one of \"None\", \"bar\",\n            \"scatter\" or \"hist\". Defaults to None.\n        overlay (bool, optional): Whether to overlay plotted lines on the\n            figure. Defaults to False.\n        position (str, optional): Position of the control, can be\n            \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults\n            to 'bottomright'.\n        min_width (int, optional): Min width of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n        max_width (int, optional): Max width of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n        min_height (int, optional): Min height of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n        max_height (int, optional): Max height of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n\n    \"\"\"\n    plot_options_dict = {}\n    plot_options_dict[\"add_marker_cluster\"] = add_marker_cluster\n    plot_options_dict[\"plot_type\"] = plot_type\n    plot_options_dict[\"overlay\"] = overlay\n    plot_options_dict[\"position\"] = position\n    plot_options_dict[\"min_width\"] = min_width\n    plot_options_dict[\"max_width\"] = max_width\n    plot_options_dict[\"min_height\"] = min_height\n    plot_options_dict[\"max_height\"] = max_height\n\n    for key in kwargs:\n        plot_options_dict[key] = kwargs[key]\n\n    self._plot_options = plot_options_dict\n\n    if not hasattr(self, \"_plot_marker_cluster\"):\n        self._plot_marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n\n    if add_marker_cluster and (self._plot_marker_cluster not in self.layers):\n        self.add(self._plot_marker_cluster)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.spectral_to_csv","title":"<code>spectral_to_csv(self, filename, index=True, **kwargs)</code>","text":"<p>Saves the spectral data to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output CSV file.</p> required <code>index</code> <code>bool</code> <p>Whether to write the index. Defaults to True.</p> <code>True</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def spectral_to_csv(self, filename, index=True, **kwargs):\n    \"\"\"Saves the spectral data to a CSV file.\n\n    Args:\n        filename (str): The output CSV file.\n        index (bool, optional): Whether to write the index. Defaults to True.\n    \"\"\"\n    df = self.spectral_to_df()\n    df = df.rename_axis(\"band\")\n    df.to_csv(filename, index=index, **kwargs)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.spectral_to_df","title":"<code>spectral_to_df(self, **kwargs)</code>","text":"<p>Converts the spectral data to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>The spectral data as a pandas DataFrame.</p> Source code in <code>prismatools/prismatools.py</code> <pre><code>def spectral_to_df(self, **kwargs):\n    \"\"\"Converts the spectral data to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: The spectral data as a pandas DataFrame.\n    \"\"\"\n    import pandas as pd\n\n    df = pd.DataFrame(self._spectral_data, **kwargs)\n    return df\n</code></pre>"},{"location":"spatial/","title":"spatial module","text":""},{"location":"usage/","title":"Usage","text":"<p>To use prismatools in a project:</p> <pre><code>import prismatools\n</code></pre>"},{"location":"utils/","title":"utils module","text":"<p>The utils module provides functions used by the other modules.</p>"},{"location":"utils/#prismatools.utils.check_valid_file","title":"<code>check_valid_file(file_path, type='PRS_L2D')</code>","text":"<p>Checks if the given file path points to a valid file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file.</p> required <code>type</code> <code>str</code> <p>Expected file type ('PRS_L2B', 'PRS_L2C', 'PRS_L2D'). Defaults to 'PRS_L2D'.</p> <code>'PRS_L2D'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if file_path points to the correct file, False otherwise.</p> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the type is unsupported.</p> Source code in <code>prismatools/utils.py</code> <pre><code>def check_valid_file(file_path: str, type: str = \"PRS_L2D\") -&gt; bool:\n    \"\"\"\n    Checks if the given file path points to a valid file.\n\n    Args:\n        file_path (str): Path to the file.\n        type (str, optional): Expected file type ('PRS_L2B', 'PRS_L2C', 'PRS_L2D'). Defaults to 'PRS_L2D'.\n\n    Returns:\n        bool: True if file_path points to the correct file, False otherwise.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the type is unsupported.\n    \"\"\"\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n\n    valid_types = {\"PRS_L2B\", \"PRS_L2C\", \"PRS_L2D\"}\n    if type not in valid_types:\n        raise ValueError(\n            f\"Unsupported file type: {type}. Supported types are {valid_types}.\"\n        )\n\n    basename = os.path.basename(file_path)\n    return basename.startswith(type) and basename.endswith(\".he5\")\n</code></pre>"},{"location":"utils/#prismatools.utils.convert_coords","title":"<code>convert_coords(coords, from_epsg, to_epsg)</code>","text":"<p>Convert a list of coordinates from one EPSG to another. Coordinates are expected in the format (lat, lon).</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>List[Tuple[float, float]]</code> <p>List of tuples containing coordinates in the format (latitude, longitude).</p> required <code>from_epsg</code> <code>str</code> <p>Source EPSG code (e.g. \"epsg:4326\").</p> required <code>to_epsg</code> <code>str</code> <p>Target EPSG code (e.g. \"epsg:32632\").</p> required <p>Returns:</p> Type Description <code>List[Tuple[float, float]]</code> <p>List of tuple containing converted coordinates (x, y)</p> Source code in <code>prismatools/utils.py</code> <pre><code>def convert_coords(\n    coords: List[Tuple[float, float]], from_epsg: str, to_epsg: str\n) -&gt; List[Tuple[float, float]]:\n    \"\"\"\n    Convert a list of coordinates from one EPSG to another. Coordinates are\n    expected in the format (lat, lon).\n\n    Args:\n        coords (List[Tuple[float, float]]):\n            List of tuples containing coordinates in the format (latitude, longitude).\n        from_epsg (str): Source EPSG code (e.g. \"epsg:4326\").\n        to_epsg (str): Target EPSG code (e.g. \"epsg:32632\").\n    Returns:\n        List of tuple containing converted coordinates (x, y)\n    \"\"\"\n    transformer = pyproj.Transformer.from_crs(from_epsg, to_epsg, always_xy=True)\n    return [transformer.transform(lon, lat) for lat, lon in coords]\n</code></pre>"},{"location":"utils/#prismatools.utils.get_transform","title":"<code>get_transform(ul_easting, ul_northing, res=30)</code>","text":"<p>Returns an affine transformation for a given upper-left corner and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>ul_easting</code> <code>float</code> <p>Easting coordinate of the upper-left corner.</p> required <code>ul_northing</code> <code>float</code> <p>Northing coordinate of the upper-left corner.</p> required <code>res</code> <code>int</code> <p>Pixel resolution. Defaults to 30.</p> <code>30</code> <p>Returns:</p> Type Description <code>Affine</code> <p>Affine transformation object representing the spatial transform.</p> Source code in <code>prismatools/utils.py</code> <pre><code>def get_transform(ul_easting: float, ul_northing: float, res: int = 30) -&gt; Affine:\n    \"\"\"\n    Returns an affine transformation for a given upper-left corner and resolution.\n\n    Args:\n        ul_easting (float): Easting coordinate of the upper-left corner.\n        ul_northing (float): Northing coordinate of the upper-left corner.\n        res (int, optional): Pixel resolution. Defaults to 30.\n\n    Returns:\n        Affine: Affine transformation object representing the spatial transform.\n    \"\"\"\n    return Affine.translation(ul_easting, ul_northing) * Affine.scale(res, -res)\n</code></pre>"},{"location":"examples/01_reading_and_exporting_PRISMA_cube/","title":"01 reading and exporting PRISMA cube","text":"In\u00a0[1]: Copied! <pre># !pip install prismatools\n</pre> # !pip install prismatools In\u00a0[2]: Copied! <pre># from prismatools.prisma import read_prismaL2D, extract_prisma\n# import numpy as np\n# import matplotlib.pyplot as plt\n</pre> # from prismatools.prisma import read_prismaL2D, extract_prisma # import numpy as np # import matplotlib.pyplot as plt In\u00a0[3]: Copied! <pre># file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n# ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\", panchromatic=False)\n# ds\n</pre> # file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" # ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\", panchromatic=False) # ds In\u00a0[4]: Copied! <pre># res = extract_prisma(dataset=ds, lat=41.4468, lon=15.4646)\n# res\n</pre> # res = extract_prisma(dataset=ds, lat=41.4468, lon=15.4646) # res In\u00a0[5]: Copied! <pre># debugging\n# if __name__ == \"__main__\":\n#     file = r\"C:/Users/loren/Desktop/PRS_L2D_STD_20240429095823_20240429095827_0001\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n#     ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\")\n#     print(ds)\n\n#     ds_pan = read_prismaL2D(file, panchromatic=True)\n#     print(ds_pan)\n\n#     # case1a: Pan from path (\u00e8 necessario specificare se \u00e8 pan o meno)\n#     write_prismaL2D(file, output=r'..\\out_test\\imgPan_path_pan.tif', panchromatic=True)\n#     # case1b: Cube from path\n#     write_prismaL2D(file, output=r'..\\out_test\\imgPan_path_cube.tif')\n\n#     # case2a: Pan from dataset\n#     write_prismaL2D(ds_pan, output=r'..\\out_test\\imgPan_ds.tif')\n#     # case2b: Cube from dataset\n#     write_prismaL2D(ds, output=r'..\\out_test\\imgCube_ds.tif')\n\n#     # case3 : Cube in ENVI format\n#     write_prismaL2D(file, output=r'..\\out_test\\imgCube_ds.dat', panchromatic=False)\n#     write_prismaL2D(file, output=r'..\\out_test\\imgPanc_ds.dat', panchromatic=True)\n</pre> # debugging # if __name__ == \"__main__\": #     file = r\"C:/Users/loren/Desktop/PRS_L2D_STD_20240429095823_20240429095827_0001\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" #     ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\") #     print(ds)  #     ds_pan = read_prismaL2D(file, panchromatic=True) #     print(ds_pan)  #     # case1a: Pan from path (\u00e8 necessario specificare se \u00e8 pan o meno) #     write_prismaL2D(file, output=r'..\\out_test\\imgPan_path_pan.tif', panchromatic=True) #     # case1b: Cube from path #     write_prismaL2D(file, output=r'..\\out_test\\imgPan_path_cube.tif')  #     # case2a: Pan from dataset #     write_prismaL2D(ds_pan, output=r'..\\out_test\\imgPan_ds.tif') #     # case2b: Cube from dataset #     write_prismaL2D(ds, output=r'..\\out_test\\imgCube_ds.tif')  #     # case3 : Cube in ENVI format #     write_prismaL2D(file, output=r'..\\out_test\\imgCube_ds.dat', panchromatic=False) #     write_prismaL2D(file, output=r'..\\out_test\\imgPanc_ds.dat', panchromatic=True) In\u00a0[6]: Copied! <pre># file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n# ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\")\n# ds\n</pre> # file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" # ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\") # ds In\u00a0[7]: Copied! <pre># # plot PRISMA L2D cube\n# wavelengths = ds.wavelength.values\n# r_idx = np.abs(wavelengths - 660).argmin()\n# g_idx = np.abs(wavelengths - 560).argmin()\n# b_idx = np.abs(wavelengths - 490).argmin()\n\n# rgb = np.stack(\n#     [\n#         ds.reflectance.values[:, :, r_idx],\n#         ds.reflectance.values[:, :, g_idx],\n#         ds.reflectance.values[:, :, b_idx],\n#     ],\n#     axis=-1,\n# )\n\n# # rgb = np.clip(rgb, 0, 1)\n# rgb_stretch = (rgb - rgb.min()) / (rgb.max() - rgb.min())\n\n# plt.imshow(rgb_stretch)\n# plt.title(\"PRISMA RGB Composite\")\n# plt.xlabel(\"x\")\n# plt.ylabel(\"y\")\n# plt.show()\n</pre> # # plot PRISMA L2D cube # wavelengths = ds.wavelength.values # r_idx = np.abs(wavelengths - 660).argmin() # g_idx = np.abs(wavelengths - 560).argmin() # b_idx = np.abs(wavelengths - 490).argmin()  # rgb = np.stack( #     [ #         ds.reflectance.values[:, :, r_idx], #         ds.reflectance.values[:, :, g_idx], #         ds.reflectance.values[:, :, b_idx], #     ], #     axis=-1, # )  # # rgb = np.clip(rgb, 0, 1) # rgb_stretch = (rgb - rgb.min()) / (rgb.max() - rgb.min())  # plt.imshow(rgb_stretch) # plt.title(\"PRISMA RGB Composite\") # plt.xlabel(\"x\") # plt.ylabel(\"y\") # plt.show() In\u00a0[8]: Copied! <pre># ds_pan = read_prismaL2D_pan(file)\n# ds_pan\n</pre> # ds_pan = read_prismaL2D_pan(file) # ds_pan In\u00a0[9]: Copied! <pre># # Plot the panchromatic reflectance\n# plt.imshow(ds_pan.reflectance.values, cmap=\"gray\", vmin=0, vmax=1)\n# plt.title(\"PRISMA Panchromatic Reflectance\")\n# plt.xlabel(\"x\")\n# plt.ylabel(\"y\")\n# plt.colorbar(label=\"Reflectance\")\n# plt.show()\n</pre> # # Plot the panchromatic reflectance # plt.imshow(ds_pan.reflectance.values, cmap=\"gray\", vmin=0, vmax=1) # plt.title(\"PRISMA Panchromatic Reflectance\") # plt.xlabel(\"x\") # plt.ylabel(\"y\") # plt.colorbar(label=\"Reflectance\") # plt.show()"},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#reading-and-exporting-prisma-cube-l2d-data","title":"Reading and Exporting PRISMA Cube L2D data\u00b6","text":""},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#01-read-prisma-cube","title":"01. read PRISMA Cube\u00b6","text":""},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#02-read-panchromatic-prisma-cube","title":"02. read panchromatic PRISMA Cube\u00b6","text":""},{"location":"examples/02_visualize_prisma/","title":"02 visualize prisma","text":"In\u00a0[1]: Copied! <pre># import prismatools\n</pre> # import prismatools In\u00a0[2]: Copied! <pre># filepath =  r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n</pre> # filepath =  r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" In\u00a0[3]: Copied! <pre># ds = prismatools.read_prismaL2D(file_path=filepath)\n# ds\n</pre> # ds = prismatools.read_prismaL2D(file_path=filepath) # ds In\u00a0[4]: Copied! <pre># m = prismatools.Map()\n# m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2)\n# m.add(\"spectral\")\n# m\n</pre> # m = prismatools.Map() # m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2) # m.add(\"spectral\") # m In\u00a0[5]: Copied! <pre># m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2)\n# m.add('spectral')\n</pre> # m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2) # m.add('spectral')"},{"location":"examples/02_visualize_prisma/#visualize-prisma-cube-l2d-data","title":"Visualize PRISMA Cube L2D data\u00b6","text":""}]}