{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to prismatools","text":"<p>prismatools is an open-source Python package for reading, analyzing, and visualizing hyperspectral imagery from the PRISMA mission.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://gthlor.github.io/prismatools</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#prismatools.common.array_to_image","title":"<code>array_to_image(array, output, dtype=None, compress='lzw', transpose=True, crs=None, transform=None, driver='GTiff', **kwargs)</code>","text":"<p>Save a NumPy array as a georeferenced raster (GeoTIFF by default).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>Array to save. Shape can be (rows, cols) or (bands, rows, cols).</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <code>dtype</code> <code>np.dtype</code> <p>Data type for output. Auto-inferred if None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>Compression for GTiff/COG. Defaults to \"lzw\".</p> <code>'lzw'</code> <code>transpose</code> <code>bool</code> <p>If True, expects (bands, rows, cols) and transposes.</p> <code>True</code> <code>crs</code> <code>str</code> <p>CRS of the output raster.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>Affine transform of the raster.</p> <code>None</code> <code>driver</code> <code>str</code> <p>GDAL driver. Defaults to \"GTiff\".</p> <code>'GTiff'</code> <code>**kwargs</code> <p>Extra options for rasterio.open().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the saved file.</p> Source code in <code>prismatools/common.py</code> <pre><code>def array_to_image(\n    array: np.ndarray,\n    output: str,\n    dtype: Optional[np.dtype] = None,\n    compress: str = \"lzw\",\n    transpose: bool = True,\n    crs: Optional[str] = None,\n    transform: Optional[tuple] = None,\n    driver: str = \"GTiff\",\n    **kwargs,\n) -&gt; str:\n    \"\"\"\n    Save a NumPy array as a georeferenced raster (GeoTIFF by default).\n\n    Args:\n        array (np.ndarray): Array to save. Shape can be (rows, cols) or (bands, rows, cols).\n        output (str): Path to the output file.\n        dtype (np.dtype, optional): Data type for output. Auto-inferred if None.\n        compress (str, optional): Compression for GTiff/COG. Defaults to \"lzw\".\n        transpose (bool, optional): If True, expects (bands, rows, cols) and transposes.\n        crs (str, optional): CRS of the output raster.\n        transform (tuple, optional): Affine transform of the raster.\n        driver (str, optional): GDAL driver. Defaults to \"GTiff\".\n        **kwargs: Extra options for rasterio.open().\n\n    Returns:\n        str: Path to the saved file.\n    \"\"\"\n    # ensure correct shape\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    # ensure output directory exists\n    os.makedirs(os.path.dirname(os.path.abspath(output)), exist_ok=True)\n\n    # get driver from extension\n    ext = os.path.splitext(output)[-1].lower()\n    driver_map = {\"\": \"COG\", \".tif\": \"GTiff\", \".tiff\": \"GTiff\", \".dat\": \"ENVI\"}\n    driver = driver_map.get(ext, \"COG\")\n    if ext == \"\":\n        output += \".tif\"\n\n    # infer dtype if not given\n    if dtype is None:\n        min_val, max_val = np.nanmin(array), np.nanmax(array)\n        if min_val &gt;= 0 and max_val &lt;= 1:\n            dtype = np.float32\n        elif min_val &gt;= 0 and max_val &lt;= 255:\n            dtype = np.uint8\n        elif min_val &gt;= -128 and max_val &lt;= 127:\n            dtype = np.int8\n        elif min_val &gt;= 0 and max_val &lt;= 65535:\n            dtype = np.uint16\n        elif min_val &gt;= -32768 and max_val &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n    array = array.astype(dtype)\n\n    # set metadata\n    count = 1 if array.ndim == 2 else array.shape[2]\n    metadata = dict(\n        driver=driver,\n        height=array.shape[0],\n        width=array.shape[1],\n        count=count,\n        dtype=array.dtype,\n        crs=crs,\n        transform=transform,\n    )\n    if compress and driver in [\"GTiff\", \"COG\"]:\n        metadata[\"compress\"] = compress\n    metadata.update(**kwargs)\n\n    # write raster\n    with rasterio.open(output, \"w\", **metadata) as dst:\n        if array.ndim == 2:  # panchromatic\n            dst.write(array, 1)\n            dst.set_band_description(\n                1, kwargs.get(\"band_description\", \"Panchromatic band\")\n            )\n        else:  # hyperspectral\n            for i in range(array.shape[2]):\n                dst.write(array[:, :, i], i + 1)\n                if \"wavelengths\" in kwargs:\n                    wl = kwargs[\"wavelengths\"][i]\n                    dst.set_band_description(i + 1, f\"Band {i+1} ({wl:.1f} nm)\")\n\n    return output\n</code></pre>"},{"location":"common/#prismatools.common.check_valid_file","title":"<code>check_valid_file(file_path, type='PRS_L2D')</code>","text":"<p>Checks if the given file path points to a valid file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file.</p> required <code>type</code> <code>str</code> <p>Expected file type ('PRS_L2B', 'PRS_L2C', 'PRS_L2D'). Defaults to 'PRS_L2D'.</p> <code>'PRS_L2D'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if file_path points to the correct file, False otherwise.</p> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the type is unsupported.</p> Source code in <code>prismatools/common.py</code> <pre><code>def check_valid_file(file_path: str, type: str = \"PRS_L2D\") -&gt; bool:\n    \"\"\"\n    Checks if the given file path points to a valid file.\n\n    Args:\n        file_path (str): Path to the file.\n        type (str, optional): Expected file type ('PRS_L2B', 'PRS_L2C', 'PRS_L2D'). Defaults to 'PRS_L2D'.\n\n    Returns:\n        bool: True if file_path points to the correct file, False otherwise.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the type is unsupported.\n    \"\"\"\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n\n    valid_types = {\"PRS_L2B\", \"PRS_L2C\", \"PRS_L2D\"}\n    if type not in valid_types:\n        raise ValueError(\n            f\"Unsupported file type: {type}. Supported types are {valid_types}.\"\n        )\n\n    basename = os.path.basename(file_path)\n    return basename.startswith(type) and basename.endswith(\".he5\")\n</code></pre>"},{"location":"common/#prismatools.common.convert_coords","title":"<code>convert_coords(coords, from_epsg, to_epsg)</code>","text":"<p>Convert a list of coordinates from one EPSG to another.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>List[Tuple[float, float]]</code> <p>List of tuples containing coordinates in the format (latitude, longitude).</p> required <code>from_epsg</code> <code>str</code> <p>Source EPSG code (default is \"epsg:4326\").</p> required <code>to_epsg</code> <code>str</code> <p>Target EPSG code (default is \"epsg:32615\").</p> required <p>Returns:</p> Type Description <code>List[Tuple[float, float]]</code> <p>List of tuples containing converted coordinates in the format (x, y).</p> Source code in <code>prismatools/common.py</code> <pre><code>def convert_coords(\n    coords: List[Tuple[float, float]], from_epsg: str, to_epsg: str\n) -&gt; List[Tuple[float, float]]:\n    \"\"\"\n    Convert a list of coordinates from one EPSG to another.\n\n    Args:\n        coords: List of tuples containing coordinates in the format (latitude, longitude).\n        from_epsg: Source EPSG code (default is \"epsg:4326\").\n        to_epsg: Target EPSG code (default is \"epsg:32615\").\n\n    Returns:\n        List of tuples containing converted coordinates in the format (x, y).\n    \"\"\"\n    import pyproj\n\n    # Define the coordinate transformation\n    transformer = pyproj.Transformer.from_crs(from_epsg, to_epsg, always_xy=True)\n\n    # Convert each coordinate\n    converted_coords = [transformer.transform(lon, lat) for lat, lon in coords]\n\n    return converted_coords\n</code></pre>"},{"location":"common/#prismatools.common.extract_prisma","title":"<code>extract_prisma(dataset, lat, lon, offset=15.0)</code>","text":"<p>Extracts an averaged reflectance spectrum from a PRISMA hyperspectral dataset.</p> <p>A square spatial window is centered at the specified latitude and longitude, and the reflectance values within that window are averaged across the spatial dimensions to produce a single spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>xarray.Dataset</code> <p>The PRISMA dataset containing reflectance data, with valid CRS information.</p> required <code>lat</code> <code>float</code> <p>Latitude of the center point.</p> required <code>lon</code> <code>float</code> <p>Longitude of the center points.</p> required <code>offset</code> <code>float</code> <p>Half-size of the square window for extraction, expressed in the dataset's projected coordinate units (e.g., meters). Defaults to 15.0.</p> <code>15.0</code> <p>Returns:</p> Type Description <code>xarray.DataArray</code> <p>A 1D array containing the averaged reflectance values across wavelengths. If no matching pixels are found, returns NaN values.</p> Source code in <code>prismatools/common.py</code> <pre><code>def extract_prisma(\n    dataset: xr.Dataset,\n    lat: float,\n    lon: float,\n    offset: float = 15.0,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Extracts an averaged reflectance spectrum from a PRISMA hyperspectral dataset.\n\n    A square spatial window is centered at the specified latitude and longitude,\n    and the reflectance values within that window are averaged across the spatial\n    dimensions to produce a single spectrum.\n\n    Args:\n        dataset (xarray.Dataset): The PRISMA dataset containing reflectance data,\n            with valid CRS information.\n        lat (float): Latitude of the center point.\n        lon (float): Longitude of the center points.\n        offset (float, optional): Half-size of the square window for extraction,\n            expressed in the dataset's projected coordinate units (e.g., meters).\n            Defaults to 15.0.\n\n    Returns:\n        xarray.DataArray: A 1D array containing the averaged reflectance values\n        across wavelengths. If no matching pixels are found, returns NaN values.\n    \"\"\"\n    if dataset.rio.crs is None:\n        raise ValueError(\"Dataset CRS not set. Please provide dataset with CRS info.\")\n\n    crs = dataset.rio.crs.to_string()\n\n    # Convert lat/lon to projected coords\n    x_proj, y_proj = convert_coords([(lat, lon)], \"epsg:4326\", crs)[0]\n\n    da = dataset[\"reflectance\"]\n    x_con = (da[\"x\"] &gt; x_proj - offset) &amp; (da[\"x\"] &lt; x_proj + offset)\n    y_con = (da[\"y\"] &gt; y_proj - offset) &amp; (da[\"y\"] &lt; y_proj + offset)\n\n    try:\n        data = da.where(x_con &amp; y_con, drop=True)\n        data = data.mean(dim=[\"x\", \"y\"], skipna=True)\n    except ValueError:\n        # No matching pixels\n        data = np.full(da.sizes[\"wavelength\"], np.nan)\n\n    return xr.DataArray(\n        data,\n        dims=[\"wavelength\"],\n        coords={\"wavelength\": dataset.coords[\"wavelength\"]},\n    )\n</code></pre>"},{"location":"common/#prismatools.common.extract_spectral","title":"<code>extract_spectral(ds, lat, lon, name='data')</code>","text":"<p>Extracts spectral signature from a given xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xarray.Dataset</code> <p>The dataset containing the spectral data.</p> required <code>lat</code> <code>float</code> <p>The latitude of the point to extract.</p> required <code>lon</code> <code>float</code> <p>The longitude of the point to extract.</p> required <p>Returns:</p> Type Description <code>xarray.DataArray</code> <p>The extracted data.</p> Source code in <code>prismatools/common.py</code> <pre><code>def extract_spectral(\n    ds: xr.Dataset, lat: float, lon: float, name: str = \"data\"\n) -&gt; xr.DataArray:\n    \"\"\"\n    Extracts spectral signature from a given xarray Dataset.\n\n    Args:\n        ds (xarray.Dataset): The dataset containing the spectral data.\n        lat (float): The latitude of the point to extract.\n        lon (float): The longitude of the point to extract.\n\n    Returns:\n        xarray.DataArray: The extracted data.\n    \"\"\"\n\n    crs = ds.rio.crs\n\n    x, y = convert_coords([[lat, lon]], \"epsg:4326\", crs)[0]\n\n    values = ds.sel(x=x, y=y, method=\"nearest\")[name].values\n\n    da = xr.DataArray(values, dims=[\"band\"], coords={\"band\": ds.coords[\"band\"]})\n\n    return da\n</code></pre>"},{"location":"common/#prismatools.common.get_transform","title":"<code>get_transform(ul_easting, ul_northing, res=30)</code>","text":"<p>Returns an affine transformation for a given upper-left corner and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>ul_easting</code> <code>float</code> <p>Easting coordinate of the upper-left corner.</p> required <code>ul_northing</code> <code>float</code> <p>Northing coordinate of the upper-left corner.</p> required <code>res</code> <code>int</code> <p>Pixel resolution. Defaults to 30.</p> <code>30</code> <p>Returns:</p> Type Description <code>Affine</code> <p>Affine transformation object representing the spatial transform.</p> Source code in <code>prismatools/common.py</code> <pre><code>def get_transform(ul_easting: float, ul_northing: float, res: int = 30) -&gt; Affine:\n    \"\"\"\n    Returns an affine transformation for a given upper-left corner and resolution.\n\n    Args:\n        ul_easting (float): Easting coordinate of the upper-left corner.\n        ul_northing (float): Northing coordinate of the upper-left corner.\n        res (int, optional): Pixel resolution. Defaults to 30.\n\n    Returns:\n        Affine: Affine transformation object representing the spatial transform.\n    \"\"\"\n    return Affine.translation(ul_easting, ul_northing) * Affine.scale(res, -res)\n</code></pre>"},{"location":"common/#prismatools.common.read_prismaL2D","title":"<code>read_prismaL2D(file_path, wavelengths=None, method='nearest', panchromatic=False)</code>","text":"<p>Reads PRISMA Level-2D .he5 data (hyperspectral or panchromatic) and returns an xarray.Dataset with reflectance values and geospatial metadata.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the PRISMA L2D .he5 file.</p> required <code>wavelengths</code> <code>Optional[List[float]]</code> <p>List of wavelengths (in nm) to extract (only for hyperspectral cube). - If None, all valid wavelengths are used. - If provided, can select by exact match or nearest available wavelength.</p> <code>None</code> <code>method</code> <code>str, default \"nearest\"</code> <p>Method for wavelength selection (\"nearest\" or \"exact\").</p> <code>'nearest'</code> <code>panchromatic</code> <code>bool, default False</code> <p>If True, read the panchromatic cube.                                 If False, read the hyperspectral cube.</p> <code>False</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>An xarray.Dataset containing reflectance data with coordinates.</p> Source code in <code>prismatools/common.py</code> <pre><code>def read_prismaL2D(\n    file_path: str,\n    wavelengths: Optional[List[float]] = None,\n    method: str = \"nearest\",\n    panchromatic: bool = False,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Reads PRISMA Level-2D .he5 data (hyperspectral or panchromatic)\n    and returns an xarray.Dataset with reflectance values and geospatial metadata.\n\n    Args:\n        file_path (str): Path to the PRISMA L2D .he5 file.\n        wavelengths (Optional[List[float]]): List of wavelengths (in nm) to extract\n            (only for hyperspectral cube).\n            - If None, all valid wavelengths are used.\n            - If provided, can select by exact match or nearest available wavelength.\n        method (str, default \"nearest\"): Method for wavelength selection (\"nearest\" or \"exact\").\n        panchromatic (bool, default False): If True, read the panchromatic cube.\n                                            If False, read the hyperspectral cube.\n\n    Returns:\n        xr.Dataset: An xarray.Dataset containing reflectance data with coordinates.\n    \"\"\"\n    # check if file is valid\n    if not check_valid_file(file_path, type=\"PRS_L2D\"):\n        raise ValueError(\n            f\"The file {file_path} is not a valid PRS_L2D file or does not exist.\"\n        )\n\n    try:\n        with h5py.File(file_path, \"r\") as f:\n            epsg_code = f.attrs[\"Epsg_Code\"][()]\n            ul_easting = f.attrs[\"Product_ULcorner_easting\"][()]\n            ul_northing = f.attrs[\"Product_ULcorner_northing\"][()]\n\n            if panchromatic:\n                # --- PANCHROMATIC ---\n                pancube_path = \"HDFEOS/SWATHS/PRS_L2D_PCO/Data Fields/Cube\"\n                pancube_data = f[pancube_path][()]\n                l2_scale_pan_min = f.attrs[\"L2ScalePanMin\"][()]\n                l2_scale_pan_max = f.attrs[\"L2ScalePanMax\"][()]\n                fill_value = -9999\n                max_data_value = 65535\n\n                pancube_data = l2_scale_pan_min + (\n                    pancube_data.astype(np.float32) / max_data_value\n                ) * (l2_scale_pan_max - l2_scale_pan_min)\n                pancube_data[pancube_data == fill_value] = np.nan\n\n                rows, cols = pancube_data.shape\n                transform = get_transform(ul_easting, ul_northing, res=5)\n                x_coords = np.array([transform * (i, 0) for i in range(cols)])[:, 0]\n                y_coords = np.array([transform * (0, j) for j in range(rows)])[:, 1]\n\n                ds = xr.Dataset(\n                    data_vars=dict(\n                        reflectance=(\n                            [\"y\", \"x\"],\n                            pancube_data,\n                            dict(\n                                units=\"unitless\",\n                                _FillValue=np.nan,\n                                standard_name=\"reflectance\",\n                                long_name=\"Panchromatic reflectance\",\n                            ),\n                        ),\n                    ),\n                    coords=dict(\n                        y=([\"y\"], y_coords, dict(units=\"m\")),\n                        x=([\"x\"], x_coords, dict(units=\"m\")),\n                    ),\n                )\n\n            else:\n                # --- HYPERSPECTRAL CUBE ---\n                swir_cube = f[\"HDFEOS/SWATHS/PRS_L2D_HCO/Data Fields/SWIR_Cube\"][()]\n                vnir_cube = f[\"HDFEOS/SWATHS/PRS_L2D_HCO/Data Fields/VNIR_Cube\"][()]\n                vnir_wavelengths = f.attrs[\"List_Cw_Vnir\"][()]\n                swir_wavelengths = f.attrs[\"List_Cw_Swir\"][()]\n                l2_scale_vnir_min = f.attrs[\"L2ScaleVnirMin\"][()]\n                l2_scale_vnir_max = f.attrs[\"L2ScaleVnirMax\"][()]\n                l2_scale_swir_min = f.attrs[\"L2ScaleSwirMin\"][()]\n                l2_scale_swir_max = f.attrs[\"L2ScaleSwirMax\"][()]\n                fill_value = -9999\n                max_data_value = 65535\n\n                vnir_cube = l2_scale_vnir_min + (\n                    vnir_cube.astype(np.float32) / max_data_value\n                ) * (l2_scale_vnir_max - l2_scale_vnir_min)\n                swir_cube = l2_scale_swir_min + (\n                    swir_cube.astype(np.float32) / max_data_value\n                ) * (l2_scale_swir_max - l2_scale_swir_min)\n\n                vnir_cube[vnir_cube == fill_value] = np.nan\n                swir_cube[swir_cube == fill_value] = np.nan\n\n                full_cube = np.concatenate((vnir_cube, swir_cube), axis=1)\n                full_wavelengths = np.concatenate((vnir_wavelengths, swir_wavelengths))\n\n                # filter and sort wavelengths\n                valid_idx = full_wavelengths &gt; 0\n                full_wavelengths = full_wavelengths[valid_idx]\n                full_cube = full_cube[:, valid_idx, :]\n                sort_idx = np.argsort(full_wavelengths)\n                full_wavelengths = full_wavelengths[sort_idx]\n                full_cube = full_cube[:, sort_idx, :]\n\n                # select requested wavelengths\n                if wavelengths is not None:\n                    requested = np.array(wavelengths)\n                    if method == \"exact\":\n                        idx = np.where(np.isin(full_wavelengths, requested))[0]\n                        if len(idx) == 0:\n                            raise ValueError(\n                                \"No requested wavelengths found (exact match).\"\n                            )\n                    else:\n                        idx = np.array(\n                            [np.abs(full_wavelengths - w).argmin() for w in requested]\n                        )\n                    full_wavelengths = full_wavelengths[idx]\n                    full_cube = full_cube[:, idx, :]\n\n                rows, cols = full_cube.shape[0], full_cube.shape[2]\n                transform = get_transform(ul_easting, ul_northing, res=30)\n                x_coords = np.array([transform * (i, 0) for i in range(cols)])[:, 0]\n                y_coords = np.array([transform * (0, j) for j in range(rows)])[:, 1]\n\n                ds = xr.Dataset(\n                    data_vars=dict(\n                        reflectance=(\n                            [\"y\", \"wavelength\", \"x\"],\n                            full_cube,\n                            dict(\n                                units=\"unitless\",\n                                _FillValue=np.nan,\n                                standard_name=\"reflectance\",\n                                long_name=\"Combined atmospherically corrected surface reflectance\",\n                            ),\n                        ),\n                    ),\n                    coords=dict(\n                        wavelength=(\n                            [\"wavelength\"],\n                            full_wavelengths,\n                            dict(long_name=\"center wavelength\", units=\"nm\"),\n                        ),\n                        y=([\"y\"], y_coords, dict(units=\"m\")),\n                        x=([\"x\"], x_coords, dict(units=\"m\")),\n                    ),\n                )\n                ds[\"reflectance\"] = ds.reflectance.transpose(\"y\", \"x\", \"wavelength\")\n\n    except Exception as e:\n        raise RuntimeError(f\"Error reading the file {file_path}: {e}\")\n\n    # write CRS and transform\n    crs = f\"EPSG:{epsg_code}\"\n    ds.rio.write_crs(crs, inplace=True)\n    ds.rio.write_transform(transform, inplace=True)\n\n    # global attributes\n    ds.attrs.update(\n        dict(\n            units=\"unitless\",\n            _FillValue=-9999,\n            grid_mapping=\"crs\",\n            standard_name=\"reflectance\",\n            Conventions=\"CF-1.6\",\n            crs=ds.rio.crs.to_string(),\n        )\n    )\n\n    return ds\n</code></pre>"},{"location":"common/#prismatools.common.write_prismaL2D","title":"<code>write_prismaL2D(dataset, output, panchromatic=False, wavelengths=None, method='nearest', **kwargs)</code>","text":"<p>Converts a PRISMA hyperspectral dataset to a georeferenced image.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Union[xr.Dataset, str]</code> <p>The PRISMA dataset or the path to the dataset file (.he5).</p> required <code>output</code> <code>str</code> <p>File path to save the output raster.</p> required <code>panchromatic</code> <code>bool</code> <p>If True, treat array as single-band pancromatic. Defaults to False.</p> <code>False</code> <code>wavelengths</code> <code>np.ndarray</code> <p>Wavelengths to select from the dataset. If None, all wavelengths are included. Defaults to None.</p> <code>None</code> <code>method</code> <code>str</code> <p>Method to use for wavelength selection (e.g. \"nearest\").</p> <code>'nearest'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to 'array_to_image()' and to 'rasterio.open()'.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Output file path, or None if all values are NaN.</p> Source code in <code>prismatools/common.py</code> <pre><code>def write_prismaL2D(\n    dataset: Union[xr.Dataset, str],\n    output: str,\n    panchromatic: bool = False,\n    wavelengths: Optional[np.ndarray] = None,\n    method: str = \"nearest\",\n    **kwargs: Any,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts a PRISMA hyperspectral dataset to a georeferenced image.\n\n    Args:\n        dataset (Union[xr.Dataset, str]): The PRISMA dataset or the path to the\n            dataset file (.he5).\n        output (str): File path to save the output raster.\n        panchromatic (bool, optional): If True, treat array as single-band pancromatic. Defaults to False.\n        wavelengths (np.ndarray, optional): Wavelengths to select from the dataset.\n            If None, all wavelengths are included. Defaults to None.\n        method (str, optional): Method to use for wavelength selection (e.g. \"nearest\").\n        **kwargs (Any): Additional arguments passed to 'array_to_image()' and to 'rasterio.open()'.\n\n    Returns:\n        str: Output file path, or None if all values are NaN.\n    \"\"\"\n    # load dataset if it's a path to .he5\n    if isinstance(dataset, str):\n        dataset = read_prismaL2D(dataset, panchromatic=panchromatic)\n\n    # get np.array\n    array = dataset[\"reflectance\"].values\n    if not np.any(np.isfinite(array)):\n        print(\"Warning: All reflectance values are NaN. Output image will be blank.\")\n        return None\n\n    # get band names (wavelength) and, eventually, select specific bands\n    if array.ndim == 2:  # panchromatic\n        kwargs[\"band_description\"] = \"Panchromatic band\"\n    else:  # cube\n        if wavelengths is not None:\n            dataset = dataset.sel(wavelength=wavelengths, method=method)\n            array = dataset[\"reflectance\"].values\n        kwargs[\"wavelengths\"] = dataset[\"wavelength\"].values\n\n    return array_to_image(\n        array,\n        output=output,\n        transpose=False,\n        crs=dataset.rio.crs,\n        transform=dataset.rio.transform(),\n        **kwargs,\n    )\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/gthlor/prismatools/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>prismatools could always use more documentation, whether as part of the official prismatools docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/gthlor/prismatools/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up prismatools for local development.</p> <ol> <li> <p>Fork the prismatools repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/prismatools.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv prismatools\n$ cd prismatools/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 prismatools tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/gthlor/prismatools/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install prismatools, run this command in your terminal:</p> <pre><code>pip install prismatools\n</code></pre> <p>This is the preferred method to install prismatools, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install prismatools from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/gthlor/prismatools\n</code></pre>"},{"location":"prismatools/","title":"prismatools module","text":"<p>Main module.</p>"},{"location":"prismatools/#prismatools.prismatools.Map","title":"<code> Map            (Map)         </code>","text":"<p>A class that extends leafmap.Map to provide additional functionality for     prismatools.</p> <p>Methods</p> <p>Any methods inherited from leafmap.Map.</p> Source code in <code>prismatools/prismatools.py</code> <pre><code>class Map(leafmap.Map):\n    \"\"\"\n    A class that extends leafmap.Map to provide additional functionality for\n        prismatools.\n\n    Attributes:\n        Any attributes inherited from leafmap.Map.\n\n    Methods:\n        Any methods inherited from leafmap.Map.\n    \"\"\"\n\n    def __init__(self, center=[0, 0], zoom=2, **kwargs):\n        \"\"\"\n        Initializes a new instance of the Map class.\n\n        Args:\n            **kwargs: Arbitrary keyword arguments that are passed to the parent\n                class's constructor.\n        \"\"\"\n        # set off toolbars not needed from Leafmap\n        kwargs[\"layers_control\"] = False\n        kwargs[\"fullscreen_control\"] = True\n        kwargs[\"search_control\"] = False\n        kwargs[\"draw_control\"] = False\n        kwargs[\"measure_control\"] = False\n        kwargs[\"scale_control\"] = True\n        kwargs[\"toolbar_control\"] = False\n\n        super().__init__(**kwargs)\n        # add my simplified toolbar\n        main_toolbar(self)\n\n        self._spectral_data = {}\n        self._plot_options = None\n\n    def add(self, obj, position=\"topright\", xlim=None, ylim=None, **kwargs):\n        \"\"\"Add a layer to the map.\n\n        Args:\n            obj (str or object): The name of the layer or a layer object.\n            position (str, optional): The position of the layer widget. Can be\n                'topright', 'topleft', 'bottomright', or 'bottomleft'. Defaults\n                to 'topright'.\n            xlim (tuple, optional): The x-axis limits of the plot. Defaults to None.\n            ylim (tuple, optional): The y-axis limits of the plot. Defaults to None.\n            **kwargs: Arbitrary keyword arguments that are passed to the parent\n                class's add_layer method.\n        \"\"\"\n\n        if isinstance(obj, str):\n            if obj == \"spectral\":\n\n                spectralWidget(self, position=position, xlim=xlim, ylim=ylim, **kwargs)\n                self.set_plot_options(add_marker_cluster=True)\n            else:\n                super().add(obj, **kwargs)\n\n        else:\n            super().add(obj, **kwargs)\n\n    def add_prisma(\n        self,\n        source,\n        wavelengths=None,\n        indexes=None,\n        colormap=None,\n        vmin=0,\n        vmax=0.5,\n        nodata=np.nan,\n        attribution=None,\n        layer_name=\"PRISMA\",\n        zoom_to_layer=True,\n        visible=True,\n        array_args=None,\n        method=\"nearest\",\n        **kwargs,\n    ):\n        \"\"\"Add a PRISMA dataset to the map.\n\n        This function reads a PRISMA hyperspectral dataset, optionally selects\n        specific wavelengths, converts the data to an image, and adds it as a\n        raster layer to the map. The dataset can be provided as a file path or\n        as an xarray Dataset.\n\n        Args:\n            source (str or xarray.Dataset): The path to the PRISMA file or an\n                in-memory xarray Dataset containing PRISMA data.\n            wavelengths (list or np.ndarray, optional): Specific wavelengths to\n                select from the dataset. If None, all wavelengths are used.\n                Defaults to None.\n            indexes (int or list, optional): The band(s) to display. Band\n                indexing starts at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib`\n                to use when plotting a single band. See:\n                https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n                Default is greyscale.\n            vmin (float, optional): The minimum value for color mapping when\n                plotting a single band. Defaults to 0.\n            vmax (float, optional): The maximum value for color mapping when\n                plotting a single band. Defaults to 0.5.\n            nodata (float, optional): Value in the raster to interpret as\n                no-data. Defaults to np.nan.\n            attribution (str, optional): Attribution for the source raster.\n                Defaults to None.\n            layer_name (str, optional): The name to assign to the map layer.\n                Defaults to \"PRISMA\".\n            zoom_to_layer (bool, optional): Whether to zoom the map to the\n                extent of the layer after adding it. Defaults to True.\n            visible (bool, optional): Whether the layer should be visible when\n                first added. Defaults to True.\n            array_args (dict, optional): Additional keyword arguments to pass to\n                `array_to_memory_file` when reading the raster. Defaults to {}.\n            method (str, optional): Method to use for wavelength interpolation\n                when selecting bands. Options may include \"nearest\", \"linear\",\n                etc. Defaults to \"nearest\".\n            **kwargs: Additional keyword arguments passed to `add_raster`.\n        \"\"\"\n        if array_args is None:\n            array_args = {}\n\n        if isinstance(source, str):\n            xds = read_prismaL2D(source)\n        else:\n            xds = source\n\n        with tempfile.NamedTemporaryFile(suffix=\".tif\", delete=False) as tmp:\n            temp_path = tmp.name\n\n        # create a temporary .tif with only selected wavelengths because leafmap (built on ipyleaflet) can add only images with 3 bands or 1 band\n        write_prismaL2D(xds, wavelengths=wavelengths, method=method, output=temp_path)\n\n        self.add_raster(  # this function will add the tiff to the map\n            temp_path,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            zoom_to_layer=zoom_to_layer,\n            visible=visible,\n            array_args=array_args,\n            **kwargs,\n        )\n\n        self.cog_layer_dict[layer_name][\n            \"xds\"\n        ] = xds  # avoid losing spectral information\n        self.cog_layer_dict[layer_name][\"hyper\"] = \"PRISMA\"\n\n    def add_raster(\n        self,\n        source,\n        indexes=None,\n        colormap=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"Raster\",\n        layer_index=None,\n        zoom_to_layer=True,\n        visible=True,\n        opacity=1.0,\n        array_args=None,\n        client_args={\"cors_all\": False},\n        open_args=None,\n        **kwargs,\n    ):\n        \"\"\"Add a local raster dataset to the map.\n            If you are using this function in JupyterHub on a remote server\n                (e.g., Binder, Microsoft Planetary Computer) and\n            if the raster does not render properly, try installing\n                jupyter-server-proxy using `pip install jupyter-server-proxy`,\n            then running the following code before calling this function. For\n                more info, see https://bit.ly/3JbmF93.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud\n                Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts\n                at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib`\n                to use when plotting a single band. See\n                https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n                Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping\n                the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping\n                the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret\n                as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This\n                defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n            layer_index (int, optional): The index of the layer. Defaults to None.\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the\n                layer. Defaults to True.\n            visible (bool, optional): Whether the layer is visible. Defaults to\n                True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            array_args (dict, optional): Additional arguments to pass to\n                `array_to_memory_file` when reading the raster. Defaults to {}.\n            client_args (dict, optional): Additional arguments to pass to\n                localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n            open_args (dict, optional): Additional arguments to pass to\n                rioxarray.open_rasterio.\n\n        \"\"\"\n        import rioxarray as rxr\n\n        if array_args is None:\n            array_args = {}\n        if open_args is None:\n            open_args = {}\n\n        if nodata is None:\n            nodata = np.nan\n\n        super().add_raster(\n            source,\n            indexes=indexes,  # if source has more bands, you need to specify 3 indices\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            layer_index=layer_index,\n            zoom_to_layer=zoom_to_layer,\n            visible=visible,\n            opacity=opacity,\n            array_args=array_args,\n            client_args=client_args,\n            **kwargs,\n        )\n\n        if isinstance(source, str):\n            da = rxr.open_rasterio(source, **open_args)\n            dims = da.dims\n            da = da.transpose(dims[1], dims[2], dims[0])\n\n            xds = da.to_dataset(name=\"data\")\n            self.cog_layer_dict[layer_name][\"xds\"] = xds\n\n    def spectral_to_df(self, **kwargs):\n        \"\"\"Converts the spectral data to a pandas DataFrame.\n\n        Returns:\n            pd.DataFrame: The spectral data as a pandas DataFrame.\n        \"\"\"\n        import pandas as pd\n\n        df = pd.DataFrame(self._spectral_data, **kwargs)\n        return df\n\n    def spectral_to_csv(self, filename, index=True, **kwargs):\n        \"\"\"Saves the spectral data to a CSV file.\n\n        Args:\n            filename (str): The output CSV file.\n            index (bool, optional): Whether to write the index. Defaults to True.\n        \"\"\"\n        df = self.spectral_to_df()\n        df = df.rename_axis(\"band\")\n        df.to_csv(filename, index=index, **kwargs)\n\n    def set_plot_options(\n        self,\n        add_marker_cluster=False,\n        plot_type=None,\n        overlay=False,\n        position=\"bottomright\",\n        min_width=None,\n        max_width=None,\n        min_height=None,\n        max_height=None,\n        **kwargs,\n    ):\n        \"\"\"Sets plotting options.\n\n        Args:\n            add_marker_cluster (bool, optional): Whether to add a marker cluster.\n                Defaults to False.\n            sample_scale (float, optional):  A nominal scale in meters of the\n                projection to sample in . Defaults to None.\n            plot_type (str, optional): The plot type can be one of \"None\", \"bar\",\n                \"scatter\" or \"hist\". Defaults to None.\n            overlay (bool, optional): Whether to overlay plotted lines on the\n                figure. Defaults to False.\n            position (str, optional): Position of the control, can be\n                \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults\n                to 'bottomright'.\n            min_width (int, optional): Min width of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n            max_width (int, optional): Max width of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n            min_height (int, optional): Min height of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n            max_height (int, optional): Max height of the widget (in pixels), if\n                None it will respect the content size. Defaults to None.\n\n        \"\"\"\n        plot_options_dict = {}\n        plot_options_dict[\"add_marker_cluster\"] = add_marker_cluster\n        plot_options_dict[\"plot_type\"] = plot_type\n        plot_options_dict[\"overlay\"] = overlay\n        plot_options_dict[\"position\"] = position\n        plot_options_dict[\"min_width\"] = min_width\n        plot_options_dict[\"max_width\"] = max_width\n        plot_options_dict[\"min_height\"] = min_height\n        plot_options_dict[\"max_height\"] = max_height\n\n        for key in kwargs:\n            plot_options_dict[key] = kwargs[key]\n\n        self._plot_options = plot_options_dict\n\n        if not hasattr(self, \"_plot_marker_cluster\"):\n            self._plot_marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n\n        if add_marker_cluster and (self._plot_marker_cluster not in self.layers):\n            self.add(self._plot_marker_cluster)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.__init__","title":"<code>__init__(self, center=[0, 0], zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a new instance of the Map class.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments that are passed to the parent class's constructor.</p> <code>{}</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def __init__(self, center=[0, 0], zoom=2, **kwargs):\n    \"\"\"\n    Initializes a new instance of the Map class.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments that are passed to the parent\n            class's constructor.\n    \"\"\"\n    # set off toolbars not needed from Leafmap\n    kwargs[\"layers_control\"] = False\n    kwargs[\"fullscreen_control\"] = True\n    kwargs[\"search_control\"] = False\n    kwargs[\"draw_control\"] = False\n    kwargs[\"measure_control\"] = False\n    kwargs[\"scale_control\"] = True\n    kwargs[\"toolbar_control\"] = False\n\n    super().__init__(**kwargs)\n    # add my simplified toolbar\n    main_toolbar(self)\n\n    self._spectral_data = {}\n    self._plot_options = None\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.add","title":"<code>add(self, obj, position='topright', xlim=None, ylim=None, **kwargs)</code>","text":"<p>Add a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or object</code> <p>The name of the layer or a layer object.</p> required <code>position</code> <code>str</code> <p>The position of the layer widget. Can be 'topright', 'topleft', 'bottomright', or 'bottomleft'. Defaults to 'topright'.</p> <code>'topright'</code> <code>xlim</code> <code>tuple</code> <p>The x-axis limits of the plot. Defaults to None.</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>The y-axis limits of the plot. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments that are passed to the parent class's add_layer method.</p> <code>{}</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def add(self, obj, position=\"topright\", xlim=None, ylim=None, **kwargs):\n    \"\"\"Add a layer to the map.\n\n    Args:\n        obj (str or object): The name of the layer or a layer object.\n        position (str, optional): The position of the layer widget. Can be\n            'topright', 'topleft', 'bottomright', or 'bottomleft'. Defaults\n            to 'topright'.\n        xlim (tuple, optional): The x-axis limits of the plot. Defaults to None.\n        ylim (tuple, optional): The y-axis limits of the plot. Defaults to None.\n        **kwargs: Arbitrary keyword arguments that are passed to the parent\n            class's add_layer method.\n    \"\"\"\n\n    if isinstance(obj, str):\n        if obj == \"spectral\":\n\n            spectralWidget(self, position=position, xlim=xlim, ylim=ylim, **kwargs)\n            self.set_plot_options(add_marker_cluster=True)\n        else:\n            super().add(obj, **kwargs)\n\n    else:\n        super().add(obj, **kwargs)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.add_prisma","title":"<code>add_prisma(self, source, wavelengths=None, indexes=None, colormap=None, vmin=0, vmax=0.5, nodata=nan, attribution=None, layer_name='PRISMA', zoom_to_layer=True, visible=True, array_args=None, method='nearest', **kwargs)</code>","text":"<p>Add a PRISMA dataset to the map.</p> <p>This function reads a PRISMA hyperspectral dataset, optionally selects specific wavelengths, converts the data to an image, and adds it as a raster layer to the map. The dataset can be provided as a file path or as an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str or xarray.Dataset</code> <p>The path to the PRISMA file or an in-memory xarray Dataset containing PRISMA data.</p> required <code>wavelengths</code> <code>list or np.ndarray</code> <p>Specific wavelengths to select from the dataset. If None, all wavelengths are used. Defaults to None.</p> <code>None</code> <code>indexes</code> <code>int or list</code> <p>The band(s) to display. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See: https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value for color mapping when plotting a single band. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value for color mapping when plotting a single band. Defaults to 0.5.</p> <code>0.5</code> <code>nodata</code> <code>float</code> <p>Value in the raster to interpret as no-data. Defaults to np.nan.</p> <code>nan</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The name to assign to the map layer. Defaults to \"PRISMA\".</p> <code>'PRISMA'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom the map to the extent of the layer after adding it. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer should be visible when first added. Defaults to True.</p> <code>True</code> <code>array_args</code> <code>dict</code> <p>Additional keyword arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>None</code> <code>method</code> <code>str</code> <p>Method to use for wavelength interpolation when selecting bands. Options may include \"nearest\", \"linear\", etc. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>add_raster</code>.</p> <code>{}</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def add_prisma(\n    self,\n    source,\n    wavelengths=None,\n    indexes=None,\n    colormap=None,\n    vmin=0,\n    vmax=0.5,\n    nodata=np.nan,\n    attribution=None,\n    layer_name=\"PRISMA\",\n    zoom_to_layer=True,\n    visible=True,\n    array_args=None,\n    method=\"nearest\",\n    **kwargs,\n):\n    \"\"\"Add a PRISMA dataset to the map.\n\n    This function reads a PRISMA hyperspectral dataset, optionally selects\n    specific wavelengths, converts the data to an image, and adds it as a\n    raster layer to the map. The dataset can be provided as a file path or\n    as an xarray Dataset.\n\n    Args:\n        source (str or xarray.Dataset): The path to the PRISMA file or an\n            in-memory xarray Dataset containing PRISMA data.\n        wavelengths (list or np.ndarray, optional): Specific wavelengths to\n            select from the dataset. If None, all wavelengths are used.\n            Defaults to None.\n        indexes (int or list, optional): The band(s) to display. Band\n            indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib`\n            to use when plotting a single band. See:\n            https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n            Default is greyscale.\n        vmin (float, optional): The minimum value for color mapping when\n            plotting a single band. Defaults to 0.\n        vmax (float, optional): The maximum value for color mapping when\n            plotting a single band. Defaults to 0.5.\n        nodata (float, optional): Value in the raster to interpret as\n            no-data. Defaults to np.nan.\n        attribution (str, optional): Attribution for the source raster.\n            Defaults to None.\n        layer_name (str, optional): The name to assign to the map layer.\n            Defaults to \"PRISMA\".\n        zoom_to_layer (bool, optional): Whether to zoom the map to the\n            extent of the layer after adding it. Defaults to True.\n        visible (bool, optional): Whether the layer should be visible when\n            first added. Defaults to True.\n        array_args (dict, optional): Additional keyword arguments to pass to\n            `array_to_memory_file` when reading the raster. Defaults to {}.\n        method (str, optional): Method to use for wavelength interpolation\n            when selecting bands. Options may include \"nearest\", \"linear\",\n            etc. Defaults to \"nearest\".\n        **kwargs: Additional keyword arguments passed to `add_raster`.\n    \"\"\"\n    if array_args is None:\n        array_args = {}\n\n    if isinstance(source, str):\n        xds = read_prismaL2D(source)\n    else:\n        xds = source\n\n    with tempfile.NamedTemporaryFile(suffix=\".tif\", delete=False) as tmp:\n        temp_path = tmp.name\n\n    # create a temporary .tif with only selected wavelengths because leafmap (built on ipyleaflet) can add only images with 3 bands or 1 band\n    write_prismaL2D(xds, wavelengths=wavelengths, method=method, output=temp_path)\n\n    self.add_raster(  # this function will add the tiff to the map\n        temp_path,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        zoom_to_layer=zoom_to_layer,\n        visible=visible,\n        array_args=array_args,\n        **kwargs,\n    )\n\n    self.cog_layer_dict[layer_name][\n        \"xds\"\n    ] = xds  # avoid losing spectral information\n    self.cog_layer_dict[layer_name][\"hyper\"] = \"PRISMA\"\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.add_raster","title":"<code>add_raster(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Raster', layer_index=None, zoom_to_layer=True, visible=True, opacity=1.0, array_args=None, client_args={'cors_all': False}, open_args=None, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server         (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try installing         jupyter-server-proxy using <code>pip install jupyter-server-proxy</code>,     then running the following code before calling this function. For         more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>layer_index</code> <code>int</code> <p>The index of the layer. Defaults to None.</p> <code>None</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>None</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.</p> <code>{'cors_all': False}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rioxarray.open_rasterio.</p> <code>None</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"Raster\",\n    layer_index=None,\n    zoom_to_layer=True,\n    visible=True,\n    opacity=1.0,\n    array_args=None,\n    client_args={\"cors_all\": False},\n    open_args=None,\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server\n            (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try installing\n            jupyter-server-proxy using `pip install jupyter-server-proxy`,\n        then running the following code before calling this function. For\n            more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud\n            Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts\n            at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib`\n            to use when plotting a single band. See\n            https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n            Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping\n            the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping\n            the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret\n            as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This\n            defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        layer_index (int, optional): The index of the layer. Defaults to None.\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the\n            layer. Defaults to True.\n        visible (bool, optional): Whether the layer is visible. Defaults to\n            True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        array_args (dict, optional): Additional arguments to pass to\n            `array_to_memory_file` when reading the raster. Defaults to {}.\n        client_args (dict, optional): Additional arguments to pass to\n            localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n        open_args (dict, optional): Additional arguments to pass to\n            rioxarray.open_rasterio.\n\n    \"\"\"\n    import rioxarray as rxr\n\n    if array_args is None:\n        array_args = {}\n    if open_args is None:\n        open_args = {}\n\n    if nodata is None:\n        nodata = np.nan\n\n    super().add_raster(\n        source,\n        indexes=indexes,  # if source has more bands, you need to specify 3 indices\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        layer_index=layer_index,\n        zoom_to_layer=zoom_to_layer,\n        visible=visible,\n        opacity=opacity,\n        array_args=array_args,\n        client_args=client_args,\n        **kwargs,\n    )\n\n    if isinstance(source, str):\n        da = rxr.open_rasterio(source, **open_args)\n        dims = da.dims\n        da = da.transpose(dims[1], dims[2], dims[0])\n\n        xds = da.to_dataset(name=\"data\")\n        self.cog_layer_dict[layer_name][\"xds\"] = xds\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.set_plot_options","title":"<code>set_plot_options(self, add_marker_cluster=False, plot_type=None, overlay=False, position='bottomright', min_width=None, max_width=None, min_height=None, max_height=None, **kwargs)</code>","text":"<p>Sets plotting options.</p> <p>Parameters:</p> Name Type Description Default <code>add_marker_cluster</code> <code>bool</code> <p>Whether to add a marker cluster. Defaults to False.</p> <code>False</code> <code>sample_scale</code> <code>float</code> <p>A nominal scale in meters of the projection to sample in . Defaults to None.</p> required <code>plot_type</code> <code>str</code> <p>The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay plotted lines on the figure. Defaults to False.</p> <code>False</code> <code>position</code> <code>str</code> <p>Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>min_width</code> <code>int</code> <p>Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_width</code> <code>int</code> <p>Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>min_height</code> <code>int</code> <p>Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_height</code> <code>int</code> <p>Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def set_plot_options(\n    self,\n    add_marker_cluster=False,\n    plot_type=None,\n    overlay=False,\n    position=\"bottomright\",\n    min_width=None,\n    max_width=None,\n    min_height=None,\n    max_height=None,\n    **kwargs,\n):\n    \"\"\"Sets plotting options.\n\n    Args:\n        add_marker_cluster (bool, optional): Whether to add a marker cluster.\n            Defaults to False.\n        sample_scale (float, optional):  A nominal scale in meters of the\n            projection to sample in . Defaults to None.\n        plot_type (str, optional): The plot type can be one of \"None\", \"bar\",\n            \"scatter\" or \"hist\". Defaults to None.\n        overlay (bool, optional): Whether to overlay plotted lines on the\n            figure. Defaults to False.\n        position (str, optional): Position of the control, can be\n            \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults\n            to 'bottomright'.\n        min_width (int, optional): Min width of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n        max_width (int, optional): Max width of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n        min_height (int, optional): Min height of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n        max_height (int, optional): Max height of the widget (in pixels), if\n            None it will respect the content size. Defaults to None.\n\n    \"\"\"\n    plot_options_dict = {}\n    plot_options_dict[\"add_marker_cluster\"] = add_marker_cluster\n    plot_options_dict[\"plot_type\"] = plot_type\n    plot_options_dict[\"overlay\"] = overlay\n    plot_options_dict[\"position\"] = position\n    plot_options_dict[\"min_width\"] = min_width\n    plot_options_dict[\"max_width\"] = max_width\n    plot_options_dict[\"min_height\"] = min_height\n    plot_options_dict[\"max_height\"] = max_height\n\n    for key in kwargs:\n        plot_options_dict[key] = kwargs[key]\n\n    self._plot_options = plot_options_dict\n\n    if not hasattr(self, \"_plot_marker_cluster\"):\n        self._plot_marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n\n    if add_marker_cluster and (self._plot_marker_cluster not in self.layers):\n        self.add(self._plot_marker_cluster)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.spectral_to_csv","title":"<code>spectral_to_csv(self, filename, index=True, **kwargs)</code>","text":"<p>Saves the spectral data to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output CSV file.</p> required <code>index</code> <code>bool</code> <p>Whether to write the index. Defaults to True.</p> <code>True</code> Source code in <code>prismatools/prismatools.py</code> <pre><code>def spectral_to_csv(self, filename, index=True, **kwargs):\n    \"\"\"Saves the spectral data to a CSV file.\n\n    Args:\n        filename (str): The output CSV file.\n        index (bool, optional): Whether to write the index. Defaults to True.\n    \"\"\"\n    df = self.spectral_to_df()\n    df = df.rename_axis(\"band\")\n    df.to_csv(filename, index=index, **kwargs)\n</code></pre>"},{"location":"prismatools/#prismatools.prismatools.Map.spectral_to_df","title":"<code>spectral_to_df(self, **kwargs)</code>","text":"<p>Converts the spectral data to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>The spectral data as a pandas DataFrame.</p> Source code in <code>prismatools/prismatools.py</code> <pre><code>def spectral_to_df(self, **kwargs):\n    \"\"\"Converts the spectral data to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: The spectral data as a pandas DataFrame.\n    \"\"\"\n    import pandas as pd\n\n    df = pd.DataFrame(self._spectral_data, **kwargs)\n    return df\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use prismatools in a project:</p> <pre><code>import prismatools\n</code></pre>"},{"location":"examples/01_reading_and_exporting_PRISMA_cube/","title":"01 reading and exporting PRISMA cube","text":"In\u00a0[1]: Copied! <pre># !pip install prismatools\n</pre> # !pip install prismatools In\u00a0[2]: Copied! <pre>from prismatools.common import read_prismaL2D\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from prismatools.common import read_prismaL2D import numpy as np import matplotlib.pyplot as plt In\u00a0[3]: Copied! <pre># file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n# ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\")\n# ds\n</pre> # file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" # ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\") # ds In\u00a0[4]: Copied! <pre># # plot PRISMA L2D cube\n# wavelengths = ds.wavelength.values\n# r_idx = np.abs(wavelengths - 660).argmin()\n# g_idx = np.abs(wavelengths - 560).argmin()\n# b_idx = np.abs(wavelengths - 490).argmin()\n\n# rgb = np.stack(\n#     [\n#         ds.reflectance.values[:, :, r_idx],\n#         ds.reflectance.values[:, :, g_idx],\n#         ds.reflectance.values[:, :, b_idx],\n#     ],\n#     axis=-1,\n# )\n\n# # rgb = np.clip(rgb, 0, 1)\n# rgb_stretch = (rgb - rgb.min()) / (rgb.max() - rgb.min())\n\n# plt.imshow(rgb_stretch)\n# plt.title(\"PRISMA RGB Composite\")\n# plt.xlabel(\"x\")\n# plt.ylabel(\"y\")\n# plt.show()\n</pre> # # plot PRISMA L2D cube # wavelengths = ds.wavelength.values # r_idx = np.abs(wavelengths - 660).argmin() # g_idx = np.abs(wavelengths - 560).argmin() # b_idx = np.abs(wavelengths - 490).argmin()  # rgb = np.stack( #     [ #         ds.reflectance.values[:, :, r_idx], #         ds.reflectance.values[:, :, g_idx], #         ds.reflectance.values[:, :, b_idx], #     ], #     axis=-1, # )  # # rgb = np.clip(rgb, 0, 1) # rgb_stretch = (rgb - rgb.min()) / (rgb.max() - rgb.min())  # plt.imshow(rgb_stretch) # plt.title(\"PRISMA RGB Composite\") # plt.xlabel(\"x\") # plt.ylabel(\"y\") # plt.show() In\u00a0[5]: Copied! <pre># ds_pan = read_prismaL2D_pan(file)\n# ds_pan\n</pre> # ds_pan = read_prismaL2D_pan(file) # ds_pan In\u00a0[6]: Copied! <pre># # Plot the panchromatic reflectance\n# plt.imshow(ds_pan.reflectance.values, cmap=\"gray\", vmin=0, vmax=1)\n# plt.title(\"PRISMA Panchromatic Reflectance\")\n# plt.xlabel(\"x\")\n# plt.ylabel(\"y\")\n# plt.colorbar(label=\"Reflectance\")\n# plt.show()\n</pre> # # Plot the panchromatic reflectance # plt.imshow(ds_pan.reflectance.values, cmap=\"gray\", vmin=0, vmax=1) # plt.title(\"PRISMA Panchromatic Reflectance\") # plt.xlabel(\"x\") # plt.ylabel(\"y\") # plt.colorbar(label=\"Reflectance\") # plt.show()"},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#reading-and-exporting-prisma-cube-l2d-data","title":"Reading and Exporting PRISMA Cube L2D data\u00b6","text":""},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#01-read-prisma-cube","title":"01. read PRISMA Cube\u00b6","text":""},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#02-read-panchromatic-prisma-cube","title":"02. read panchromatic PRISMA Cube\u00b6","text":""},{"location":"examples/02_visualize_prisma/","title":"02 visualize prisma","text":"In\u00a0[1]: Copied! <pre># import prismatools\n</pre> # import prismatools In\u00a0[2]: Copied! <pre># filepath =  r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n</pre> # filepath =  r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" In\u00a0[3]: Copied! <pre># ds = prismatools.read_prismaL2D(file_path=filepath)\n</pre> # ds = prismatools.read_prismaL2D(file_path=filepath) In\u00a0[4]: Copied! <pre># m = prismatools.Map()\n# m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2)\n# m.add(\"spectral\")\n# m\n</pre> # m = prismatools.Map() # m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2) # m.add(\"spectral\") # m In\u00a0[5]: Copied! <pre># m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2)\n# m.add('spectral')\n</pre> # m.add_prisma(ds, wavelengths=[650.0, 550.0, 450.0], vmin=0, vmax=0.2) # m.add('spectral')"},{"location":"examples/02_visualize_prisma/#visualize-prisma-cube-l2d-data","title":"Visualize PRISMA Cube L2D data\u00b6","text":""}]}