{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to prismatools","text":"<p>prismatools is an open-source Python package for reading, analyzing, and visualizing hyperspectral imagery from the PRISMA mission.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://gthlor.github.io/prismatools</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#prismatools.common.array_to_image","title":"<code>array_to_image(array, output, dtype=None, compress='lzw', transpose=True, crs=None, transform=None, driver='GTiff', **kwargs)</code>","text":"<p>Save a NumPy array as a georeferenced raster (GeoTIFF by default).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>Array to save. Shape can be (rows, cols) or (bands, rows, cols).</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <code>dtype</code> <code>np.dtype</code> <p>Data type for output. Auto-inferred if None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>Compression for GTiff/COG. Defaults to \"lzw\".</p> <code>'lzw'</code> <code>transpose</code> <code>bool</code> <p>If True, expects (bands, rows, cols) and transposes.</p> <code>True</code> <code>crs</code> <code>str</code> <p>CRS of the output raster.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>Affine transform of the raster.</p> <code>None</code> <code>driver</code> <code>str</code> <p>GDAL driver. Defaults to \"GTiff\".</p> <code>'GTiff'</code> <code>**kwargs</code> <p>Extra options for rasterio.open().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the saved file.</p> Source code in <code>prismatools/common.py</code> <pre><code>def array_to_image(\n    array: np.ndarray,\n    output: str,\n    dtype: Optional[np.dtype] = None,\n    compress: str = \"lzw\",\n    transpose: bool = True,\n    crs: Optional[str] = None,\n    transform: Optional[tuple] = None,\n    driver: str = \"GTiff\",\n    **kwargs,\n) -&gt; str:\n    \"\"\"\n    Save a NumPy array as a georeferenced raster (GeoTIFF by default).\n\n    Args:\n        array (np.ndarray): Array to save. Shape can be (rows, cols) or (bands, rows, cols).\n        output (str): Path to the output file.\n        dtype (np.dtype, optional): Data type for output. Auto-inferred if None.\n        compress (str, optional): Compression for GTiff/COG. Defaults to \"lzw\".\n        transpose (bool, optional): If True, expects (bands, rows, cols) and transposes.\n        crs (str, optional): CRS of the output raster.\n        transform (tuple, optional): Affine transform of the raster.\n        driver (str, optional): GDAL driver. Defaults to \"GTiff\".\n        **kwargs: Extra options for rasterio.open().\n\n    Returns:\n        str: Path to the saved file.\n    \"\"\"\n    # ensure correct shape\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    # ensure output directory exists\n    os.makedirs(os.path.dirname(os.path.abspath(output)), exist_ok=True)\n\n    # get driver from extension\n    ext = os.path.splitext(output)[-1].lower()\n    driver_map = {\n        \"\": \"COG\",\n        \".tif\": \"GTiff\",\n        \".tiff\": \"GTiff\",\n    }\n    driver = driver_map.get(ext, \"COG\")\n    if ext == \"\":\n        output += \".tif\"\n\n    # infer dtype if not given\n    if dtype is None:\n        min_val, max_val = np.nanmin(array), np.nanmax(array)\n        if min_val &gt;= 0 and max_val &lt;= 1:\n            dtype = np.float32\n        elif min_val &gt;= 0 and max_val &lt;= 255:\n            dtype = np.uint8\n        elif min_val &gt;= -128 and max_val &lt;= 127:\n            dtype = np.int8\n        elif min_val &gt;= 0 and max_val &lt;= 65535:\n            dtype = np.uint16\n        elif min_val &gt;= -32768 and max_val &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n    array = array.astype(dtype)\n\n    # set metadata\n    count = 1 if array.ndim == 2 else array.shape[2]\n    metadata = dict(\n        driver=driver,\n        height=array.shape[0],\n        width=array.shape[1],\n        count=count,\n        dtype=array.dtype,\n        crs=crs,\n        transform=transform,\n    )\n    if compress and driver in [\"GTiff\", \"COG\"]:\n        metadata[\"compress\"] = compress\n    metadata.update(**kwargs)\n\n    # write raster\n    with rasterio.open(output, \"w\", **metadata) as dst:\n        if array.ndim == 2:  # panchromatic\n            dst.write(array, 1)\n            dst.set_band_description(\n                1, kwargs.get(\"band_description\", \"Panchromatic band\")\n            )\n        else:  # hyperspectral\n            for i in range(array.shape[2]):\n                dst.write(array[:, :, i], i + 1)\n                if \"wavelengths\" in kwargs:\n                    wl = kwargs[\"wavelengths\"][i]\n                    dst.set_band_description(i + 1, f\"Band {i+1} ({wl:.1f} nm)\")\n\n    return output\n</code></pre>"},{"location":"common/#prismatools.common.check_valid_file","title":"<code>check_valid_file(file_path, type='PRS_L2D')</code>","text":"<p>Checks if the given file path points to a valid file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file.</p> required <code>type</code> <code>str</code> <p>Expected file type ('PRS_L2B', 'PRS_L2C', 'PRS_L2D'). Defaults to 'PRS_L2D'.</p> <code>'PRS_L2D'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if file_path points to the correct file, False otherwise.</p> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the type is unsupported.</p> Source code in <code>prismatools/common.py</code> <pre><code>def check_valid_file(file_path: str, type: str = \"PRS_L2D\") -&gt; bool:\n    \"\"\"\n    Checks if the given file path points to a valid file.\n\n    Args:\n        file_path (str): Path to the file.\n        type (str, optional): Expected file type ('PRS_L2B', 'PRS_L2C', 'PRS_L2D'). Defaults to 'PRS_L2D'.\n\n    Returns:\n        bool: True if file_path points to the correct file, False otherwise.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the type is unsupported.\n    \"\"\"\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n\n    valid_types = {\"PRS_L2B\", \"PRS_L2C\", \"PRS_L2D\"}\n    if type not in valid_types:\n        raise ValueError(\n            f\"Unsupported file type: {type}. Supported types are {valid_types}.\"\n        )\n\n    basename = os.path.basename(file_path)\n    return basename.startswith(type) and basename.endswith(\".he5\")\n</code></pre>"},{"location":"common/#prismatools.common.get_transform","title":"<code>get_transform(ul_easting, ul_northing, res=30)</code>","text":"<p>Returns an affine transformation for a given upper-left corner and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>ul_easting</code> <code>float</code> <p>Easting coordinate of the upper-left corner.</p> required <code>ul_northing</code> <code>float</code> <p>Northing coordinate of the upper-left corner.</p> required <code>res</code> <code>int</code> <p>Pixel resolution. Defaults to 30.</p> <code>30</code> <p>Returns:</p> Type Description <code>Affine</code> <p>Affine transformation object representing the spatial transform.</p> Source code in <code>prismatools/common.py</code> <pre><code>def get_transform(ul_easting: float, ul_northing: float, res: int = 30) -&gt; Affine:\n    \"\"\"\n    Returns an affine transformation for a given upper-left corner and resolution.\n\n    Args:\n        ul_easting (float): Easting coordinate of the upper-left corner.\n        ul_northing (float): Northing coordinate of the upper-left corner.\n        res (int, optional): Pixel resolution. Defaults to 30.\n\n    Returns:\n        Affine: Affine transformation object representing the spatial transform.\n    \"\"\"\n    return Affine.translation(ul_easting, ul_northing) * Affine.scale(res, -res)\n</code></pre>"},{"location":"common/#prismatools.common.read_prismaL2D","title":"<code>read_prismaL2D(file_path, wavelengths=None, method='nearest')</code>","text":"<p>Reads PRISMA hyperspectral Level-2D .he5 data and returns an xarray dataset with reflectance values, associated wavelengths, and geospatial metadata.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the PRISMA L2D .he5 file.</p> required <code>wavelengths</code> <code>Optional[List[float]]</code> <p>List of wavelengths (in nm) to extract. - If None, all valid wavelengths are used. - If provided, can select by exact match or nearest available wavelength.</p> <code>None</code> <code>method</code> <code>str, default \"nearest\"</code> <p>Method to select wavelengths when <code>wavelengths</code> is provided. Options are: - \"nearest\": selects the closest available wavelength. - \"exact\": selects only wavelengths exactly matching those requested.</p> <code>'nearest'</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>An xarray.Dataset containing reflectance data with coordinates.</p> Source code in <code>prismatools/common.py</code> <pre><code>def read_prismaL2D(\n    file_path: str, wavelengths: Optional[List[float]] = None, method: str = \"nearest\"\n) -&gt; xr.Dataset:\n    \"\"\"\n    Reads PRISMA hyperspectral Level-2D .he5 data and returns an xarray dataset with\n    reflectance values, associated wavelengths, and geospatial metadata.\n\n    Args:\n        file_path (str): Path to the PRISMA L2D .he5 file.\n        wavelengths (Optional[List[float]]): List of wavelengths (in nm) to extract.\n            - If None, all valid wavelengths are used.\n            - If provided, can select by exact match or nearest available wavelength.\n        method (str, default \"nearest\"): Method to select wavelengths when `wavelengths` is provided. Options are:\n            - \"nearest\": selects the closest available wavelength.\n            - \"exact\": selects only wavelengths exactly matching those requested.\n\n    Returns:\n        xr.Dataset: An xarray.Dataset containing reflectance data with coordinates.\n    \"\"\"\n    # check if file is valid\n    if not check_valid_file(file_path, type=\"PRS_L2D\"):\n        raise ValueError(\n            f\"The file {file_path} is not a valid PRS_L2D file or does not exist.\"\n        )\n\n    # get data and metadata\n    try:\n        with h5py.File(file_path, \"r\") as f:\n            swir_cube_path = \"HDFEOS/SWATHS/PRS_L2D_HCO/Data Fields/SWIR_Cube\"\n            vnir_cube_path = \"HDFEOS/SWATHS/PRS_L2D_HCO/Data Fields/VNIR_Cube\"\n            swir_cube_data = f[swir_cube_path][()]\n            vnir_cube_data = f[vnir_cube_path][()]\n            vnir_wavelengths = f.attrs[\"List_Cw_Vnir\"][()]\n            swir_wavelengths = f.attrs[\"List_Cw_Swir\"][()]\n            l2_scale_vnir_min = f.attrs[\"L2ScaleVnirMin\"][()]\n            l2_scale_vnir_max = f.attrs[\"L2ScaleVnirMax\"][()]\n            l2_scale_swir_min = f.attrs[\"L2ScaleSwirMin\"][()]\n            l2_scale_swir_max = f.attrs[\"L2ScaleSwirMax\"][()]\n            epsg_code = f.attrs[\"Epsg_Code\"][()]\n            ul_easting = f.attrs[\"Product_ULcorner_easting\"][()]\n            ul_northing = f.attrs[\"Product_ULcorner_northing\"][()]\n    except Exception as e:\n        raise RuntimeError(f\"Error reading the file {file_path}: {e}\")\n\n    fill_value = -9999\n    max_data_value = 65535\n\n    # scale data to reflectance and set fill value to -9999\n    vnir_cube_data = l2_scale_vnir_min + (\n        vnir_cube_data.astype(np.float32) / max_data_value\n    ) * (l2_scale_vnir_max - l2_scale_vnir_min)\n    swir_cube_data = l2_scale_swir_min + (\n        swir_cube_data.astype(np.float32) / max_data_value\n    ) * (l2_scale_swir_max - l2_scale_swir_min)\n\n    vnir_cube_data[vnir_cube_data == fill_value] = np.nan\n    swir_cube_data[swir_cube_data == fill_value] = np.nan\n\n    # combine VNIR and SWIR data\n    full_cube_data = np.concatenate((vnir_cube_data, swir_cube_data), axis=1)\n    full_wavelengths = np.concatenate((vnir_wavelengths, swir_wavelengths))\n\n    # filter wavelengths if specified or corrupted\n    valid_indices = full_wavelengths &gt; 0\n    full_wavelengths = full_wavelengths[valid_indices]\n    full_cube_data = full_cube_data[:, valid_indices, :]\n\n    sort_indices = np.argsort(full_wavelengths)\n    full_wavelengths = full_wavelengths[sort_indices]\n    full_cube_data = full_cube_data[:, sort_indices, :]\n\n    if wavelengths is not None:\n        requested = np.array(wavelengths)\n        available = full_wavelengths\n\n        if method == \"exact\":\n            idx = np.where(np.isin(available, requested))[0]\n            if len(idx) == 0:\n                raise ValueError(\n                    \"No requested wavelengths found in the data (exact match).\"\n                )\n        else:  # \"nearest\"\n            # find the closest available wavelengths to those requested\n            idx = np.array([np.abs(available - w).argmin() for w in requested])\n\n        full_cube_data = full_cube_data[:, idx, :]\n        full_wavelengths = available[idx]\n\n    # create coordinates and geotransform\n    rows = full_cube_data.shape[0]\n    cols = full_cube_data.shape[2]\n\n    transform = get_transform(ul_easting, ul_northing, res=30)\n    x_coords = np.array([transform * (i, 0) for i in range(cols)])[:, 0]\n    y_coords = np.array([transform * (0, j) for j in range(rows)])[:, 1]\n\n    crs = f\"EPSG:{epsg_code}\"\n    if crs is None:\n        raise ValueError(\n            \"Dataset has no CRS. Please ensure read_prisma writes CRS before returning.\"\n        )\n\n    # create xarray dataset\n    ds = xr.Dataset(\n        data_vars=dict(\n            reflectance=(\n                [\"y\", \"wavelength\", \"x\"],\n                full_cube_data,\n                dict(\n                    units=\"unitless\",\n                    _FillValue=np.nan,\n                    standard_name=\"reflectance\",\n                    long_name=\"Combined atmospherically corrected surface reflectance\",\n                ),\n            ),\n        ),\n        coords=dict(\n            wavelength=(\n                [\"wavelength\"],\n                full_wavelengths,\n                dict(long_name=\"center wavelength\", units=\"nm\"),\n            ),\n            y=([\"y\"], y_coords, dict(units=\"m\")),\n            x=([\"x\"], x_coords, dict(units=\"m\")),\n        ),\n    )\n\n    ds[\"reflectance\"] = ds.reflectance.transpose(\"y\", \"x\", \"wavelength\")\n    ds.rio.write_crs(crs, inplace=True)\n    ds.rio.write_transform(transform, inplace=True)\n\n    global_atts = ds.attrs\n    global_atts[\"Conventions\"] = \"CF-1.6\"\n    ds.attrs = dict(\n        units=\"unitless\",\n        _FillValue=-9999,\n        grid_mapping=\"crs\",\n        standard_name=\"reflectance\",\n        long_name=\"atmospherically corrected surface reflectance\",\n        crs=ds.rio.crs.to_string(),\n    )\n    ds.attrs.update(global_atts)\n    return ds\n</code></pre>"},{"location":"common/#prismatools.common.read_prismaL2D_pan","title":"<code>read_prismaL2D_pan(file_path)</code>","text":"<p>Reads PRISMA panchromatic Level-2D .he5 data and returns an xarray dataset with reflectance values and geospatial metadata.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the PRISMA L2D panchromatic .he5 file.</p> required <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>An xarray.Dataset containing reflectance data with coordinates.</p> Source code in <code>prismatools/common.py</code> <pre><code>def read_prismaL2D_pan(file_path: str) -&gt; xr.Dataset:\n    \"\"\"\n    Reads PRISMA panchromatic Level-2D .he5 data and returns an xarray dataset with\n    reflectance values and geospatial metadata.\n\n    Args:\n        file_path (str): Path to the PRISMA L2D panchromatic .he5 file.\n\n    Returns:\n        xr.Dataset: An xarray.Dataset containing reflectance data with coordinates.\n    \"\"\"\n    # check if file is valid\n    if not check_valid_file(file_path, type=\"PRS_L2D\"):\n        raise ValueError(\n            f\"The file {file_path} is not a valid PRS_L2D file or does not exist.\"\n        )\n\n    # get data and metadata\n    try:\n        with h5py.File(file_path, \"r\") as f:\n            pancube_path = \"HDFEOS/SWATHS/PRS_L2D_PCO/Data Fields/Cube\"\n            pancube_data = f[pancube_path][()]\n            l2_scale_pan_min = f.attrs[\"L2ScalePanMin\"][()]\n            l2_scale_pan_max = f.attrs[\"L2ScalePanMax\"][()]\n            epsg_code = f.attrs[\"Epsg_Code\"][()]\n            ul_easting = f.attrs[\"Product_ULcorner_easting\"][()]\n            ul_northing = f.attrs[\"Product_ULcorner_northing\"][()]\n    except Exception as e:\n        raise RuntimeError(f\"Error reading the file {file_path}: {e}\")\n\n    fill_value = -9999\n    max_data_value = 65535\n\n    # scale data to reflectance and set fill value to -9999\n    pancube_data = l2_scale_pan_min + (\n        pancube_data.astype(np.float32) / max_data_value\n    ) * (l2_scale_pan_max - l2_scale_pan_min)\n    pancube_data[pancube_data == fill_value] = np.nan\n\n    # create coordinates and geotransform\n    rows = pancube_data.shape[0]\n    cols = pancube_data.shape[1]\n\n    transform = get_transform(ul_easting, ul_northing, res=5)\n    x_coords = np.array([transform * (i, 0) for i in range(cols)])[:, 0]\n    y_coords = np.array([transform * (0, j) for j in range(rows)])[:, 1]\n\n    crs = f\"EPSG:{epsg_code}\"\n    if crs is None:\n        raise ValueError(\n            \"Dataset has no CRS. Please ensure read_prisma writes CRS before returning.\"\n        )\n    # create xarray dataset\n    ds = xr.Dataset(\n        data_vars=dict(\n            reflectance=(\n                [\"y\", \"x\"],\n                pancube_data,\n                dict(\n                    units=\"unitless\",\n                    _FillValue=np.nan,\n                    standard_name=\"reflectance\",\n                    long_name=\"Panchromatic atmospherically corrected surface reflectance\",\n                ),\n            ),\n        ),\n        coords=dict(\n            y=([\"y\"], y_coords, dict(units=\"m\")),\n            x=([\"x\"], x_coords, dict(units=\"m\")),\n        ),\n    )\n    ds.rio.write_crs(crs, inplace=True)\n    ds.rio.write_transform(transform, inplace=True)\n    global_atts = ds.attrs\n    global_atts[\"Conventions\"] = \"CF-1.6\"\n    ds.attrs = dict(\n        units=\"unitless\",\n        _FillValue=-9999,\n        grid_mapping=\"crs\",\n        standard_name=\"reflectance\",\n        long_name=\"atmospherically corrected surface reflectance\",\n        crs=ds.rio.crs.to_string(),\n    )\n    ds.attrs.update(global_atts)\n    return ds\n</code></pre>"},{"location":"common/#prismatools.common.write_prismaL2D","title":"<code>write_prismaL2D(dataset, output, panchromatic=False, wavelengths=None, method='nearest', **kwargs)</code>","text":"<p>Converts a PRISMA hyperspectral dataset to a georeferenced image.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Union[xr.Dataset, str]</code> <p>The PRISMA dataset or the path to the dataset file (.he5).</p> required <code>output</code> <code>str</code> <p>File path to save the output raster.</p> required <code>panchromatic</code> <code>bool</code> <p>If True, treat array as single-band pancromatic.</p> <code>False</code> <code>wavelengths</code> <code>np.ndarray</code> <p>Wavelengths to select from the dataset. If None, all wavelengths are included. Defaults to None.</p> <code>None</code> <code>method</code> <code>str</code> <p>Method to use for wavelength selection (e.g. \"nearest\").</p> <code>'nearest'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to 'array_to_image()' and to 'rasterio.open()'.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Output file path, or None if all values are NaN.</p> Source code in <code>prismatools/common.py</code> <pre><code>def write_prismaL2D(\n    dataset: Union[xr.Dataset, str],\n    output: str,\n    panchromatic: bool = False,\n    wavelengths: Optional[np.ndarray] = None,\n    method: str = \"nearest\",\n    **kwargs: Any,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts a PRISMA hyperspectral dataset to a georeferenced image.\n\n    Args:\n        dataset (Union[xr.Dataset, str]): The PRISMA dataset or the path to the\n            dataset file (.he5).\n        output (str): File path to save the output raster.\n        panchromatic (bool, optional): If True, treat array as single-band pancromatic.\n        wavelengths (np.ndarray, optional): Wavelengths to select from the dataset.\n            If None, all wavelengths are included. Defaults to None.\n        method (str, optional): Method to use for wavelength selection (e.g. \"nearest\").\n        **kwargs (Any): Additional arguments passed to 'array_to_image()' and to 'rasterio.open()'.\n\n    Returns:\n        str: Output file path, or None if all values are NaN.\n    \"\"\"\n    # load dataset if it's a path to .he5\n    if isinstance(dataset, str):\n        dataset = (\n            read_prismaL2D_pan(dataset) if panchromatic else read_prismaL2D(dataset)\n        )\n\n    # get np.array\n    array = dataset[\"reflectance\"].values\n    if not np.any(np.isfinite(array)):\n        print(\"Warning: All reflectance values are NaN. Output image will be blank.\")\n        return None\n\n    # get band names (wavelength) and, eventually, select specific bands\n    if array.ndim == 2:  # panchromatic\n        kwargs[\"band_description\"] = \"Panchromatic band\"\n    else:  # cube\n        if wavelengths is not None:\n            dataset = dataset.sel(wavelength=wavelengths, method=method)\n            array = dataset[\"reflectance\"].values\n        kwargs[\"wavelengths\"] = dataset[\"wavelength\"].values\n\n    return array_to_image(\n        array,\n        output=output,\n        transpose=False,\n        crs=dataset.rio.crs,\n        transform=dataset.rio.transform(),\n        **kwargs,\n    )\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/gthlor/prismatools/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>prismatools could always use more documentation, whether as part of the official prismatools docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/gthlor/prismatools/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up prismatools for local development.</p> <ol> <li> <p>Fork the prismatools repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/prismatools.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv prismatools\n$ cd prismatools/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 prismatools tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/gthlor/prismatools/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install prismatools, run this command in your terminal:</p> <pre><code>pip install prismatools\n</code></pre> <p>This is the preferred method to install prismatools, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install prismatools from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/gthlor/prismatools\n</code></pre>"},{"location":"prismatools/","title":"prismatools module","text":"<p>Main module.</p>"},{"location":"usage/","title":"Usage","text":"<p>To use prismatools in a project:</p> <pre><code>import prismatools\n</code></pre>"},{"location":"examples/01_reading_and_exporting_PRISMA_cube/","title":"01 reading and exporting PRISMA cube","text":"In\u00a0[1]: Copied! <pre># !pip install prismatools\n</pre> # !pip install prismatools In\u00a0[2]: Copied! <pre>from prismatools.common import read_prismaL2D, read_prismaL2D_pan\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from prismatools.common import read_prismaL2D, read_prismaL2D_pan import numpy as np import matplotlib.pyplot as plt In\u00a0[3]: Copied! <pre># file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\"\n# ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\")\n# ds\n</pre> # file = r\"..\\..\\data\\PRS_L2D_STD_20240429095823_20240429095827_0001.he5\" # ds = read_prismaL2D(file, wavelengths=None, method=\"nearest\") # ds In\u00a0[4]: Copied! <pre># # plot PRISMA L2D cube\n# wavelengths = ds.wavelength.values\n# r_idx = np.abs(wavelengths - 660).argmin()\n# g_idx = np.abs(wavelengths - 560).argmin()\n# b_idx = np.abs(wavelengths - 490).argmin()\n\n# rgb = np.stack(\n#     [\n#         ds.reflectance.values[:, :, r_idx],\n#         ds.reflectance.values[:, :, g_idx],\n#         ds.reflectance.values[:, :, b_idx],\n#     ],\n#     axis=-1,\n# )\n\n# # rgb = np.clip(rgb, 0, 1)\n# rgb_stretch = (rgb - rgb.min()) / (rgb.max() - rgb.min())\n\n# plt.imshow(rgb_stretch)\n# plt.title(\"PRISMA RGB Composite\")\n# plt.xlabel(\"x\")\n# plt.ylabel(\"y\")\n# plt.show()\n</pre> # # plot PRISMA L2D cube # wavelengths = ds.wavelength.values # r_idx = np.abs(wavelengths - 660).argmin() # g_idx = np.abs(wavelengths - 560).argmin() # b_idx = np.abs(wavelengths - 490).argmin()  # rgb = np.stack( #     [ #         ds.reflectance.values[:, :, r_idx], #         ds.reflectance.values[:, :, g_idx], #         ds.reflectance.values[:, :, b_idx], #     ], #     axis=-1, # )  # # rgb = np.clip(rgb, 0, 1) # rgb_stretch = (rgb - rgb.min()) / (rgb.max() - rgb.min())  # plt.imshow(rgb_stretch) # plt.title(\"PRISMA RGB Composite\") # plt.xlabel(\"x\") # plt.ylabel(\"y\") # plt.show() In\u00a0[5]: Copied! <pre># ds_pan = read_prismaL2D_pan(file)\n# ds_pan\n</pre> # ds_pan = read_prismaL2D_pan(file) # ds_pan In\u00a0[6]: Copied! <pre># # Plot the panchromatic reflectance\n# plt.imshow(ds_pan.reflectance.values, cmap=\"gray\", vmin=0, vmax=1)\n# plt.title(\"PRISMA Panchromatic Reflectance\")\n# plt.xlabel(\"x\")\n# plt.ylabel(\"y\")\n# plt.colorbar(label=\"Reflectance\")\n# plt.show()\n</pre> # # Plot the panchromatic reflectance # plt.imshow(ds_pan.reflectance.values, cmap=\"gray\", vmin=0, vmax=1) # plt.title(\"PRISMA Panchromatic Reflectance\") # plt.xlabel(\"x\") # plt.ylabel(\"y\") # plt.colorbar(label=\"Reflectance\") # plt.show()"},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#reading-and-exporting-prisma-cube-l2d-data","title":"Reading and Exporting PRISMA Cube L2D data\u00b6","text":""},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#01-read-prisma-cube","title":"01. read PRISMA Cube\u00b6","text":""},{"location":"examples/01_reading_and_exporting_PRISMA_cube/#02-read-panchromatic-prisma-cube","title":"02. read panchromatic PRISMA Cube\u00b6","text":""}]}